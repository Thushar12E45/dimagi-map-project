<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Density Clustering</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>

    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"/>

    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        #map {
            height: 500px;
            width: 100%;
        }

        #info {
            font-size: 18px;
            margin-top: 10px;
        }

        .hidden {
            display: none;
        }

        .swal-toast {
            border-radius: 5px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #csvUpload::-webkit-file-upload-button { visibility: hidden; }
        #csvUpload { 
            width: 0.1px; /* Minimize input width */
            height: 0.1px;
            opacity: 0;
            overflow: hidden;
            position: absolute;
            z-index: -1;
        }
        /* Style the label to look like a button */
        #csvUploadLabel {
            display: inline-block;
            padding: 6px 12px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        #csvUploadLabel:hover { background-color: #45a049; }
        #uploaded-file-name { margin-left: 10px; }

    </style>
</head>
<body>

<h2>Building Density Clustering</h2>
<p>Draw a polygon on the map to see the number of buildings and their cluster representation.</p>

<div id="map"></div>
<br>
<input type="file" id="csvUpload" accept=".csv" onchange="uploadCSVPolygon()">
    <label for="csvUpload" id="csvUploadLabel">Upload CSV</label>
    <span id="uploaded-file-name">No File chosen</span>

<p id="info">Buildings in selected area: <span id="building-count">0</span></p>
<p id="clusterCount">Service Areas Created: <span id="cluster-count-val">0</span></p>

</div>

<div>
    <div>
        <label for="clusteringType">Select Service Area Grouping Method:</label>
        <select id="clusteringType" onchange="toggleInputFields()">
            <option value="kMeans">K-Means Clustering</option>
            <option value="balancedKMeans">Balanced K Means</option>
            <!-- <option value="binarySearch">Cluster by Binary Search</option>
            <option value="sampleAndScale">Cluster by Sampling and Scaling</option> -->
            <!-- <option value="dbScan">DB Scan</option>
            <option value="hierarchicalClustering">Hierarchical Clustering</option>
            <option value="greedyDivision">Greedy Division</option> -->
        </select>
    </div>
    <div id="noOfClustersIP" class="hidden">
        <br>
        <label for="noOfClusters">Number of Service Areas:</label>
        <input type="number" id="noOfClusters" min="1" value="3">
    </div>
    <div id="noOfBuildingsIP" class="hidden">
        <br>
        <label for="noOfBuildings">No of Buildings</label>
        <input type="number" id="noOfBuildings" value="250">
    </div>
    <div id="thresholdValueIP" class="hidden">
        <br>
        <label for="thresholdVal">Tolerance Value as %:</label>
        <input type="number" id="thresholdVal" step="0.01" value="10">
    </div>
    <div id="gridLengthIP">
        <br>
        <label for="gridLength">Delivery Unit Length in metres:</label>
        <input type="number" id="gridLength" step="0.01" value="50">
    </div>
    <br>
</div>

<button onclick="fetchData(oaLangLats, false)" disabled id="run-clustering">Get Service Areas</button>
<button onclick="getGrids(oaLangLats)" disabled id="get-grids" >Get Delivery Units</button>
<button onclick="clearClusters();" id = "clear-clusters" disabled>Clear Service Areas</button>
<button onclick="clearOA();" id = "clear-oa" disabled>Clear Map</button>
<button onclick="downloadGmapData();" id = "download-csv" disabled>Download CSV</button>

<script>
    const hostUrl = "https://map-clustering.onrender.com"
    let oaLangLats = []
    let clustersDataExists = false;
    let gridsDataExists = false;
    let lastFetchedData = {}
    function toggleInputFields() {
        var method = document.getElementById("clusteringType").value;
        document.getElementById("noOfClustersIP").style.display = (method === "kMeans") ? "block" : "none";
        document.getElementById("thresholdValueIP").style.display = (method === "hierarchicalClustering" || (method === "kMeans") || (method === "balancedKMeans")) ? "block" : "none";
        document.getElementById("noOfBuildingsIP").style.display = (method === "greedyDivision" || (method === "dbScan" || (method === "balancedKMeans"))) ? "block" : "none";
    }


    toggleInputFields();
    // var map = L.map('map').setView([9.0880, 7.4958],16); // Centered on Abuja, Nigeria
    var map = L.map('map').setView([9.082, 8.6753], 6); // Centered on Nigeria
    // var map = L.map('map').setView([13.3041, 7.7968],14); // Centered on Abuja, Nigeria

    // Add OpenStreetMap layer
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);


    const wardsIndex = new RBush();
    const facilitiesIndex = new RBush();
    let wardsLayer = null;
    let healthFacilitiesLayer = null;
    let loadedWardsBounds = null;
    let loadedHealthBounds = null;
    Promise.all([
        fetch('/static/nigeria_ward.geojson').then(r => r.json()),
        fetch('/static/nigeria_health_facilities.geojson').then(r => r.json())
    ]).then(([wardsData, facilitiesData]) => {
        setupIndex(wardsData, wardsIndex, 'polygon');
        setupIndex(facilitiesData, facilitiesIndex, 'point');
        updateMapLayers();
    });

    const updateMapLayers = debounce(() => {
        updateWards();
        updateHealthFacilities();
    }, 200);
    map.on('zoomend moveend', updateMapLayers);

    // Enable drawing tools
    var drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    var drawControl = new L.Control.Draw({
        draw: {
            polygon: true,
            rectangle: true,
            polyline: false,
            circle: false,
            marker: false
        },
        edit: {featureGroup: drawnItems}
    });
    map.addControl(drawControl);

    // Layer for displaying buildings
    var buildingsLayer = L.geoJSON(null, {
        style: function () {
            return {color: "red", weight: 1, fillOpacity: 0.4};
        }
    }).addTo(map);

    // Cluster Layer
    var clusterLayer = L.featureGroup().addTo(map);
    var densityLayer = L.geoJSON(null).addTo(map);

    let isDrawing = false;
    map.on(L.Draw.Event.DRAWSTART, function (e) {
        isDrawing = true;
    });
    
    map.on(L.Draw.Event.CREATED, function (event) {
        addOrUpdatePolygon(event.layer)
    });

    map.on(L.Draw.Event.EDITED, function (event) {
        event.layers.eachLayer(function (layer) {
            addOrUpdatePolygon(layer);
        });
    });

    function clearClusters() {
        buildingsLayer.clearLayers();
        clusterLayer.clearLayers();
        densityLayer.clearLayers();
        document.getElementById('cluster-count-val').innerText = 0;
        resetFields()
        enableOrDisableFields("download-csv" ,!(gridsDataExists && clustersDataExists))
        enableOrDisableFields("clear-clusters", true);
    }
    function resetFields() {
        clustersDataExists = false;
        gridsDataExists = false;
        lastFetchedData = {}
    }

    function enableOrDisableFields(field, disable) {
        document.getElementById(field).disabled = disable;
    }

    function clearOA() {
        oaLangLats = []
        drawnItems.clearLayers();
        enableOrDisableFields("run-clustering", true);
        enableOrDisableFields("get-grids", true);
        clearClusters()
        enableOrDisableFields("clear-oa", true);
        document.getElementById("uploaded-file-name").innerText = 'No File Chosen';
    }

    function addOrUpdatePolygon(layers) {
        clearOA()
        isDrawing = false;

        // Get the polygon coordinates and close the loop
        var latlngs = layers.getLatLngs()[0].map(coord => [coord.lat, coord.lng]);
        latlngs.push(latlngs[0]); // Ensure polygon is closed

        // Create and add the polygon layer
        var polygonLayer = L.polygon(latlngs, {
            color: 'blue',
            weight: 1,
            fillOpacity: 0
        }).addTo(drawnItems);

        // Fit map to polygon bounds
        map.fitBounds(polygonLayer.getBounds());
        oaLangLats = layers.getLatLngs()[0].map(coord => [coord.lng, coord.lat]);
        enableOrDisableFields("run-clustering", false);
        enableOrDisableFields("get-grids", false);
        enableOrDisableFields("clear-oa", false);
    }

    function addBuildings(data) {
        // Overlay building polygons
        if (data.buildings) {
            // Ensure that each feature gets the corresponding cluster label
            data.buildings.features.forEach((feature, index) => {
                feature.properties.cluster_label = data.buildings.cluster_label[index]; // Assign label to properties
            });

            // Now, render the GeoJSON with updated cluster labels
            L.geoJSON(data.buildings, {
                style: function (feature) {
                    const clusterLabel = feature.properties.cluster_label; // Access updated label
                    return {
                        color: getColorForNumber(clusterLabel), // Assign color based on cluster
                        weight: 1,
                        fillOpacity: 0.9
                    };
                }
            }).addTo(buildingsLayer);
        }
    }

    function addGrids(data) {
        if (data.grids) {
            L.geoJSON(data.grids, {
                style: function (feature) {
                    return {
                        color: "blue",
                        weight: 1,
                        fillOpacity: 0
                    };
                }
            }).addTo(densityLayer);
            lastFetchedData.grids = data.grids
        }
    }

    function addClusters(data) {
        if (data.clusters) {
            const clusterGroups = {};
            let noOfClusters = 0;
            // Group points by cluster ID and calculate number of buildings per cluster
            data.clusters.forEach(feature => {
                const {cluster, coordinates, numOfBuildings} = feature;

                if (clusteringType != 'dbScan' || cluster != -1) {
                    if (!clusterGroups[cluster]) {
                        noOfClusters += 1
                        clusterGroups[cluster] = {points: [], numOfBuildings: 0};
                    }

                    clusterGroups[cluster].points.push(coordinates);
                    clusterGroups[cluster].numOfBuildings = numOfBuildings;

                }
            });
            document.getElementById('cluster-count-val').innerText = noOfClusters;
            // Draw cluster boundaries and popups
            Object.entries(clusterGroups).forEach(([clusterId, {points, numOfBuildings}]) => {
                if (points.length > 2) {
                    const turfPoints = points.map(p => turf.point(p));
                    const featureCollection = turf.featureCollection(turfPoints);
                    const boundary = turf.convex(featureCollection);

                    if (boundary) {
                        // Use your vibrant color function
                        const color = getColorForNumber(parseInt(clusterId)); // Assuming you have this function

                        // Add boundary layer
                        const boundaryLayer = L.geoJSON(boundary, {color: color, fillOpacity: 0});
                        boundaryLayer.bindPopup(`Cluster ${parseInt(clusterId, 10) + 1} \n Number of Buildings: ${numOfBuildings}`);
                        clusterLayer.addLayer(boundaryLayer);
                    }
                }
            });
        }
    }

    function fetchData(polygon) {
        clearClusters();
        enableOrDisableFields("clear-clusters", true);
        enableOrDisableFields("clear-oa", true);
        clustersDataExists = false
        lastFetchedData = {}
        enableOrDisableFields("download-csv" ,!(gridsDataExists && clustersDataExists))
        let thresholdVal = document.getElementById("thresholdVal").value || 0.5;
        let clusteringType = document.getElementById("clusteringType").value;
        let noOfClusters = document.getElementById("noOfClusters").value;
        let noOfBuildings = document.getElementById("noOfBuildings").value;
        let gridLength = document.getElementById("gridLength").value;

        showToast('Fetching data...', 'info', undefined, '#ff9300');

        fetch(`${hostUrl}/get_building_density`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({polygon, thresholdVal, clusteringType, noOfClusters, noOfBuildings, gridLength})
        })
        .then(response => {
            enableOrDisableFields("clear-clusters", false);
            enableOrDisableFields("clear-oa", false);
            return response.json()
        })
        .then(data => {
            Swal.close();
            if (data.error) {
                // Handle custom error from backend
                showToast(`Error: ${data.error}`, 'error', 5000, '#FF0000', '300px');
            } else {
                showToast('Data loaded!', 'success', 2000, '#4CAF50');
                document.getElementById('building-count').innerText = data.building_count !== undefined
                        ? data.building_count
                        : "Error fetching data";

                addBuildings(data);
                addClusters(data);
                addGrids(data);
                lastFetchedData = data
                clustersDataExists = true
                enableOrDisableFields("download-csv" ,!(gridsDataExists && clustersDataExists))
            }
        })
        .catch(error => {
            Swal.close();
            showToast(`Error: ${error.message}`, 'error', 5000, '#FF0000', '300px');

            console.error('Error:', error);
            document.getElementById('building-count').innerText = "Error fetching data";
            enableOrDisableFields("clear-clusters", false);
            enableOrDisableFields("clear-oa", false);
        });
    }

    function showToast(title, icon, timer, background, width = '250px') {
        Swal.fire({
            toast: true,
            position: 'bottom-start',  // Bottom-left
            title: title,
            icon: icon,
            showConfirmButton: false,
            timer: timer,
            width: width,
            padding: '5px',  // Reduced for smaller height
            background: background,
            color: '#FFFFFF',  // White text
            customClass: {popup: 'swal-toast'}
        });
    }

    function getGrids(polygon) {
        enableOrDisableFields("clear-clusters", true);
        enableOrDisableFields("clear-oa", true);
        let gridLength = document.getElementById("gridLength").value;
        gridsDataExists = false
        enableOrDisableFields("download-csv" ,!(gridsDataExists && clustersDataExists))
        // Show fetching toast
        showToast('Fetching Delivery Units...', 'info', undefined, '#ff9300');

        fetch(`${hostUrl}/get_grids`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({polygon, gridLength})
        })
        .then(response => {
            enableOrDisableFields("clear-clusters", false);
            enableOrDisableFields("clear-oa", false);
            return response.json()
        })
        .then(data => {
            Swal.close();
            // Close fetching toast and show success toast
            if (data.error) {
                showToast(`Error: ${data.error}`, 'error', 5000, '#FF0000', '300px');
            } else {
                showToast('Delivery Units loaded!', 'success', 2000, '#4CAF50');

                densityLayer.clearLayers();
                addGrids(data);
                gridsDataExists = true
                enableOrDisableFields("download-csv" ,!(gridsDataExists && clustersDataExists))
            }
        })
        .catch(error => {
            // Close fetching toast and show error toast
            Swal.close();
            showToast(`Error: ${error.message}`, 'error', 5000, '#FF0000', '300px');

            console.error('Error:', error);
            enableOrDisableFields("clear-clusters", false);
            enableOrDisableFields("clear-oa", false);
        });
    }

    function getColorForNumber(num) {
        const hue = (num * 137) % 360;
        return `hsl(${hue}, 90%, 50%)`;
    }

    function setupIndex(data, index, type) {
        index.load(data.features.map(f => {
            const coords = f.geometry.coordinates;
            const [minLng, minLat, maxLng, maxLat] = type === 'point'
                    ? [coords[0], coords[1], coords[0], coords[1]]
                    : turf.bbox(f);
            return {minX: minLng, minY: minLat, maxX: maxLng, maxY: maxLat, feature: f};
        }));
    }

    function updateWards() {
        const zoom = map.getZoom();
        if (zoom <= 10) {
            wardsLayer?.clearLayers();
            loadedWardsBounds = null;
            return;
        }

        const bounds = map.getBounds();
        if (loadedWardsBounds && loadedWardsBounds.contains(bounds)) {
            return;
        }

        const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
        const visible = wardsIndex.search({minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3]})
                .map(item => item.feature);

        if (!wardsLayer) wardsLayer = L.geoJson(null, {
            style: {color: "black", weight: 1, fillOpacity: 0, dashArray: "4,4"},
            interactive: false,
            onEachFeature: (feature, layer) => layer.bindPopup(feature.properties.ward_name)
        }).addTo(map);
        wardsLayer.clearLayers().addData({type: "FeatureCollection", features: visible});
        loadedWardsBounds = bounds;
    }

    function updateHealthFacilities() {
        const zoom = map.getZoom();
        if (zoom <= 11) {
            healthFacilitiesLayer?.clearLayers();
            loadedHealthBounds = null;
            return;
        }

        const bounds = map.getBounds();
        if (loadedHealthBounds && loadedHealthBounds.contains(bounds)) {
            return;
        }

        const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
        const visible = facilitiesIndex.search({minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3]})
                .map(item => item.feature);

        if (!healthFacilitiesLayer) {
            healthFacilitiesLayer = L.markerClusterGroup({maxClusterRadius: 40}).addTo(map);
        }
        healthFacilitiesLayer.clearLayers().addLayers(visible.map(f =>
                L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]])
                        .bindPopup(`<b>${f.properties.name}</b><br>Ward: ${f.properties.ward_name}`)
        ));

        loadedHealthBounds = bounds;
    }

    function debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(this, args), wait);
        };
    }


    // map.on('click', function(e) {
    //     if(isDrawing) return;
    //     var lat = e.latlng.lat;
    //     var lng = e.latlng.lng;

    //     // Remove existing markers before adding a new one
    //     if (window.currentMarker) {
    //         map.removeLayer(window.currentMarker);
    //     }

    //     // Drop a new pin (marker)
    //     window.currentMarker = L.marker([lat, lng]).addTo(map)
    //         .bindPopup(`Dropped Pin<br>Lat: ${lat}, Lng: ${lng}`)
    //         .openPopup();
    //     sendCoordinatesToBackend(lat, lng)
    // });

    function sendCoordinatesToBackend(lat, lng) {
        var algo = document.getElementById("clusteringType").value;
        fetch('http://127.0.0.1:5000/get_cluster', { // Replace with your backend API
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({lat: lat, lon: lng, algo})
        })
        .then(response => response.json())
        .then(data => {
            clearClusters()
            document.getElementById('building-count').innerText = data.building_count;
            L.geoJSON(data.buildings, {
                style: function (feature) {
                    return {
                        color: 'red',
                        weight: 1,
                        fillOpacity: 0.4
                    };
                }
            }).addTo(buildingsLayer);

            let boundary = turf.convex(data.buildings);

            if (boundary) {
                L.geoJSON(boundary, {
                    style: {
                        color: 'blue',  // Boundary color
                        weight: 1,
                        fillOpacity: 0.1
                    }
                }).addTo(clusterLayer);
            }
        })
        .catch(error => console.error('Error sending coordinates:', error));
    }


    function downloadGmapData() {
        const clusterGroups = {};
        let noOfClusters = 0;
        lastFetchedData.clusters.forEach(feature => {
            const { cluster, coordinates, numOfBuildings } = feature;
            // Assuming clusteringType is accessible globally or passed; adjust if needed
            if (clusteringType !== 'dbScan' || cluster !== -1) {
                if (!clusterGroups[cluster]) {
                    noOfClusters += 1;
                    clusterGroups[cluster] = { points: [], numOfBuildings: 0 };
                }
                clusterGroups[cluster].points.push(coordinates);
                clusterGroups[cluster].numOfBuildings = numOfBuildings;
            }
        });


        // Generate CSV with WKT polygons
        let clusterCsvContent = "WKT,name,description\n";
        Object.entries(clusterGroups).forEach(([clusterId, { points, numOfBuildings }]) => {
            if (points.length > 2) {
                const turfPoints = points.map(p => turf.point(p));
                const featureCollection = turf.featureCollection(turfPoints);
                const boundary = turf.convex(featureCollection);

                if (boundary) {
                    // Extract polygon coordinates and convert to WKT
                    const coords = boundary.geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    const wkt = `POLYGON ((${coords}, ${boundary.geometry.coordinates[0][0][0]} ${boundary.geometry.coordinates[0][0][1]}))`; // Close the polygon
                    const name = `Cluster ${clusterId}`;
                    const description = `${numOfBuildings} buildings`;
                    clusterCsvContent += `"${wkt}",${name},${description}\n`;
                }
            }
        });

        if (lastFetchedData.grids) {
            lastFetchedData.grids.forEach((grid, index) => {
                const geometry = grid.geometry;
                if (geometry && geometry.type === "Polygon" && Array.isArray(geometry.coordinates)) {
                    const coords = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    const wkt = `POLYGON ((${coords}, ${geometry.coordinates[0][0][0]} ${geometry.coordinates[0][0][1]}))`;
                    const name = `Grid ${index + 1}`;
                    const description = `${grid.properties.count || 0} buildings`;
                    clusterCsvContent += `"${wkt}",${name},${description}\n`;
                } else {
                    console.error("Invalid grid geometry:", grid);
                }
            });
        }

        let buildingsCsvContent = "WKT,name,description\n";
        lastFetchedData.buildings.features.forEach((feature, index) => {
            const geometry = feature.geometry;
            if (geometry && geometry.type === "Polygon" && Array.isArray(geometry.coordinates)) {
                // Convert polygon coordinates to WKT format
                const coords = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                const wkt = `POLYGON ((${coords}, ${geometry.coordinates[0][0][0]} ${geometry.coordinates[0][0][1]}))`;
                const clusterLabel = feature.properties.cluster_label; // Use cluster label or default
                const name = `Building ${index + 1}`;
                const description = `Cluster: ${clusterLabel}`;
                buildingsCsvContent += `"${wkt}",${name},${description}\n`;
            } else {
                console.error("Invalid building geometry:", feature);
            }
        });
        
        downloadCsv(clusterCsvContent, 'service_area_&_delivery_units.csv')
        downloadCsv(buildingsCsvContent, 'buildings.csv')
        showToast("CSV downloaded! Import into Google My Maps at mymaps.google.com.", "success", 3000, "#00FF00");
    }

    function downloadCsv(csvContent, fileName) {
        const blob = new Blob([csvContent], { type: "text/csv" });
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);

    }

    function uploadCSVPolygon() {
        clearOA(); // Clear existing OA layers

        const fileInput = document.getElementById("csvUpload");
        const file = fileInput.files[0];
        if (!file) return showToast("Please select a CSV file.", "warning", 3000, "#FFA500");

        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const rows = event.target.result.split('\n').filter(row => row.trim());
                if (rows.length < 2) throw new Error("CSV has no data rows.");

                const parseCSVRow = row => {
                    const fields = [];
                    let inQuotes = false, field = '';
                    for (let char of row) {
                        if (char === '"') inQuotes = !inQuotes;
                        else if (char === ',' && !inQuotes) {
                            fields.push(field.trim());
                            field = '';
                        } else {
                            field += char;
                        }
                    }
                    fields.push(field.trim());
                    return fields;
                };

                const [header, firstDataRow] = [parseCSVRow(rows[0]), parseCSVRow(rows[1])];
                if (firstDataRow.length < 2) throw new Error("CSV row lacks sufficient columns.");

                const wktString = firstDataRow[1];
                if (!wktString.match(/^POLYGON \(\(.*\)\)$/)) throw new Error("Invalid WKT format in CSV.");

                const coordsStr = wktString.match(/POLYGON \(\((.*?)\)\)/)?.[1];
                if (!coordsStr) throw new Error("Could not parse POLYGON coordinates.");

                const latLngs = coordsStr.split(', ').map(coord => {
                    const [lon, lat] = coord.split(' ').map(Number);
                    if (isNaN(lon) || isNaN(lat)) throw new Error("Invalid coordinate values.");
                    return [lat, lon]; // lonlat to latlon
                });

                const mockLayer = {
                    getLatLngs: () => [latLngs.map(([lat, lng]) => ({ lat, lng }))],
                    getBounds: () => L.latLngBounds(latLngs)
                };

                addOrUpdatePolygon(mockLayer);
                showToast("OA loaded from CSV!", "success", 2000, "#4CAF50");
                document.getElementById("uploaded-file-name").innerText = file.name;
            } catch (error) {
                showToast(`Error: ${error.message}`, "error", 3000, "#FF0000");
                document.getElementById("uploaded-file-name").innerText = 'No File Chosen';
            } finally {
                fileInput.value = ''; // Reset input in all cases
            }
        };
        reader.onerror = () => showToast("Error reading CSV file.", "error", 3000, "#FF0000");
        reader.readAsText(file);
    }
</script>

</body>
</html>
