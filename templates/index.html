<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Density Clustering</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Leaflet and related libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <!-- Other libraries -->
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- jQuery and Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        #container {
            display: flex;
            height: 95vh;
            width: 100vw;
        }

        #left-panel {
            flex: 3;
            padding: 10px;
            position: relative; /* For absolute positioning of button */
            transition: flex 0.3s ease;
        }
        #left-panel.expanded {
            flex: 1 1 100%; /* Expand to full width when sidebar is collapsed */
        }

        #right-panel {
            width: 27vw;
            padding: 10px;
            background-color: #f5f5f5;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        #right-panel.collapsed {
            width: 0;
            transform: translateX(100%);
            padding: 0;
        }

        .card {
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .card-body {
            padding: 15px;
        }

        .btn {
            padding: 10px;
            font-size: 14px;
        }

        .color-box {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 1px solid #999;
            border-radius: 4px;
            margin-left: 10px;
        }

        #grid-details {
            height: 30%;
            overflow-y: auto;
        }

        .cursor-pointer {
            cursor: pointer;
            font-size: 18px;
            color: #555;
        }
        #sidebar-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1000;
            font-size: 20px;
            background: #fff; /* White background */
            border: 1px solid #ccc; /* Subtle border for definition */
            border-radius: 50%; /* Circular shape */
            width: 34px; /* Fixed width for circle */
            height: 34px; /* Fixed height for circle */
            color: #333;
            padding: 0; /* Remove padding to center icon */
            display: flex;
            align-items: center;
            justify-content: center; /* Center the icon */
            transition: color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease; /* Added shadow transition */
        }

        #sidebar-toggle-btn:hover {
            color: #007bff;
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow on hover */
        }
        .card-text {
            margin-bottom: 2px !important 
        }

    </style>
</head>
<body>
    <div class="container-fluid p-0">
        <h3 class="mb-0 ms-3">Building Density Clustering</h3>
        <div id="container">
            <div id="left-panel">
                <button id="sidebar-toggle-btn" title="Toggle Sidebar">
                    <i class="bi bi-chevron-right"></i> <!-- Hamburger icon by default -->
                </button>
                <div id="map" class="mb-3"></div>
                <div id="grid-details" class="card" hidden>
                    <div class="card-body">
                        <h5 class="card-title">Delivery Unit Details <span id="close-grid-details" class="float-end cursor-pointer">Ã—</span></h5>
                        <p id="grid-no" class="card-text">Grid No: None</p>
                        <p id="cluster-no" class="card-text">Cluster No: None</p>
                        <p id="grid-color" class="card-text">Cluster Color: <span class="color-box" style="background-color: transparent;"></span></p>
                        <p id="grid-buildings" class="card-text">Buildings in the Grid: 0</p>
                        <div class="mb-1" style="width: 30%;">
                            <label for="neighbor-clusters" class="form-label">Reassign to Cluster:</label>
                            <div class="input-group">
                                <select class="form-select" id="neighbor-clusters"></select>
                                <button class="btn btn-success" id="reassign-cluster" onclick="reassignGridToCluster()">Reassign</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="right-panel">
                <!-- CSV Operations -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">CSV Operations</h5>
                        <div class="row g-2">
                            <div class="col-6">
                                <input type="text" id="csvDownload" class="d-none" onclick="downloadSampleCsv()">
                                <label for="csvDownload" class="btn btn-secondary w-100">Download Sample CSV</label>
                            </div>
                            <div class="col-6">
                                <input type="file" id="csvUpload" accept=".csv" class="d-none" onchange="uploadCSVPolygon()">
                                <label for="csvUpload" class="btn btn-success w-100">Upload CSV</label>
                            </div>
                        </div>
                        <span id="uploaded-file-name" class="d-block text-muted mt-2">No File Chosen</span>
                    </div>
                </div>

                <!-- Area Details -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Area Details</h5>
                        <p id="info">Buildings in selected area: <span id="building-count">0</span></p>
                        <p id="clusterCount">Service Areas Created: <span id="cluster-count-val">0</span></p>
                    </div>
                </div>

                <!-- Clustering Settings -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Clustering Settings</h5>
                        <div class="mb-3">
                            <label for="clusteringType" class="form-label">Select Service Area Grouping Method:</label>
                            <select class="form-select" id="clusteringType" onchange="toggleInputFields()">
                                <option value="kMeans">K-Means Clustering</option>
                                <option value="balancedKMeans">Balanced K Means</option>
                                <option value="bottomUp">Bottom-Up Approach</option>
                            </select>
                        </div>
                        <div id="noOfClustersIP" class="mb-3 d-none">
                            <label for="noOfClusters" class="form-label">Number of Service Areas:</label>
                            <input type="number" class="form-control" id="noOfClusters" min="1" value="3">
                        </div>
                        <div id="noOfBuildingsIP" class="mb-3 d-none">
                            <label for="noOfBuildings" class="form-label">No of Buildings:</label>
                            <input type="number" class="form-control" id="noOfBuildings" value="250">
                        </div>
                        <div id="thresholdValueIP" class="mb-3 d-none">
                            <label for="thresholdVal" class="form-label">Tolerance Value as %:</label>
                            <input type="number" class="form-control" id="thresholdVal" step="0.01" value="10" min="0" max="100">
                        </div>
                        <div class="mb-3">
                            <label for="gridLength" class="form-label">Delivery Unit Length in metres:</label>
                            <input type="number" class="form-control" id="gridLength" step="0.01" value="50">
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Actions</h5>
                        <div class="row g-2">
                            <div class="col-6">
                                <button class="btn btn-success w-100" onclick="fetchData(oaLangLats, pinLatLng, true)" id="run-clustering" disabled>Get Service Areas</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-warning w-100" onclick="clearClusters(false)" id="clear-clusters" disabled>Clear Service Areas</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-success w-100" onclick="drawGrids(lastFetchedData)" id="get-grids" disabled>Get Delivery Units</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-warning w-100" onclick="clearGrids(); addClusters(lastFetchedData, true)" id="clear-grids" disabled>Clear Delivery Units</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-danger w-100" onclick="clearOA()" id="clear-oa" disabled>Clear Map</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-primary w-100" onclick="downloadOAWkt()" id="downloadOaWkt" disabled>Download OA WKT</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-primary w-100" onclick="downloadGmapData(gridsData)" id="download-csv" disabled>Download CSV For My Maps</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-primary w-100" onclick="downloadCsvForCommCare(gridsData, gridAssignments)" id="download-csv-commcare" disabled>Download CSV For CommCare</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants and Global Variables
        let hostUrl = "https://map-clustering.onrender.com";
        let oaLangLats = [];
        let clustersDataExists = false;
        let gridsDataExists = false;
        let lastFetchedData = {};
        let gridAssignments = new Map();
        let gridsData = {};
        let drawnGrids = [];
        let processedData = { clusters: [], grids: [], buildings: [] };
        let selectedGridIndex = null;
        let pinLatLng = null;
        let mapDefaultHeight = '100%';

        // Map Setup
        const map = L.map('map').setView([9.082, 8.6753], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const blackMarkerIcon = L.icon({
            iconUrl: 'https://cdn.jsdelivr.net/gh/pointhi/leaflet-color-markers@master/img/marker-icon-black.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        const drawnItems = new L.FeatureGroup().addTo(map);
        const drawControl = new L.Control.Draw({
            draw: { polygon: true, rectangle: true, polyline: false, circle: false, marker: { icon: blackMarkerIcon } },
            edit: { featureGroup: drawnItems }
        }).addTo(map);

        const buildingsLayer = L.geoJSON(null, {
            style: () => ({ color: "black", weight: 1, fillOpacity: 0.9 })
        }).addTo(map);

        const clusterLayer = L.featureGroup().addTo(map);
        const densityLayer = L.geoJSON(null).addTo(map);

        // Wards and Facilities Setup
        const wardsIndex = new RBush();
        const facilitiesIndex = new RBush();
        let wardsLayer = null, healthFacilitiesLayer = null;
        let loadedWardsBounds = null, loadedHealthBounds = null;

        Promise.all([
            fetch('/static/nigeria_ward.geojson').then(r => r.json()),
            fetch('/static/nigeria_health_facilities.geojson').then(r => r.json())
        ]).then(([wardsData, facilitiesData]) => {
            setupIndex(wardsData, wardsIndex, 'polygon');
            setupIndex(facilitiesData, facilitiesIndex, 'point');
            updateMapLayers();
        });

        const updateMapLayers = debounce(() => {
            updateWards();
            updateHealthFacilities();
        }, 200);
        map.on('zoomend moveend', updateMapLayers);

        // Draw Events
        let isDrawing = false;
        map.on(L.Draw.Event.DRAWSTART, () => {
            isDrawing = true;
        });

        function handleLayerEvent(layer, layerType = null) {
            clearOA(); // Clear existing drawings

            if (layerType === 'marker' || layer instanceof L.Marker) {
                pinLatLng = [layer.getLatLng().lng, layer.getLatLng().lat];
                drawnItems.addLayer(layer);
                map.panTo(layer.getLatLng());
                $('#run-clustering, #clear-oa, #downloadOaWkt').prop('disabled', false);
                oaLangLats = [];
            } else if (layerType === 'polygon' || layerType === 'rectangle' || layer instanceof L.Polygon) {
                addOrUpdatePolygon(layer);
                pinLatLng = null;
            }
        }

        map.on(L.Draw.Event.CREATED, (event) => handleLayerEvent(event.layer, event.layerType));
        map.on(L.Draw.Event.EDITED, (event) => {
            event.layers.eachLayer(layer => handleLayerEvent(layer));
        });

        // Utility Functions
        function showToast(title, icon, timer, background, width = '250px') {
            Swal.fire({
                toast: true,
                position: 'bottom-start',
                title,
                icon,
                showConfirmButton: false,
                timer,
                width,
                padding: '5px',
                background,
                color: '#FFFFFF'
            });
        }

        function getColorForNumber(num) {
            if (num == null || num == undefined) return "black";
            const hue = (num * 137) % 360;
            return `hsl(${hue}, 90%, 50%)`;
        }

        function enableOrDisableHtmlAttribute(id, value, attribute = 'disabled') {
            $('#' + id).prop(attribute, value);
        }

        function toggleInputFields() {
            const method = $('#clusteringType').val();
            $('#noOfClustersIP, #noOfBuildingsIP, #thresholdValueIP').addClass('d-none');
            $('#gridLengthIP, #thresholdValueIP').removeClass('d-none');

            if (method === "kMeans") {
                $('#noOfClustersIP').removeClass('d-none');
            } else if (method === "balancedKMeans") {
                $('#noOfBuildingsIP').removeClass('d-none');
            } else if (method === "bottomUp") {
                $('#noOfClustersIP, #noOfBuildingsIP').removeClass('d-none');
            }

            $('#close-grid-details').off('click').on('click', () => reSizeMap(mapDefaultHeight, true));
        }

        // Map Data Functions
        function setupIndex(data, index, type) {
            index.load(data.features.map(f => {
                const coords = f.geometry.coordinates;
                const [minLng, minLat, maxLng, maxLat] = type === 'point'
                    ? [coords[0], coords[1], coords[0], coords[1]]
                    : turf.bbox(f);
                return { minX: minLng, minY: minLat, maxX: maxLng, maxY: maxLat, feature: f };
            }));
        }

        function updateWards() {
            const zoom = map.getZoom();
            if (zoom <= 10) {
                wardsLayer?.clearLayers();
                loadedWardsBounds = null;
                return;
            }

            const bounds = map.getBounds();
            if (loadedWardsBounds && loadedWardsBounds.contains(bounds)) return;

            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
            const visible = wardsIndex.search({ minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3] })
                .map(item => item.feature);

            if (!wardsLayer) {
                wardsLayer = L.geoJson(null, {
                    style: { color: "black", weight: 1, fillOpacity: 0, dashArray: "4,4" },
                    interactive: false,
                    onEachFeature: (feature, layer) => layer.bindPopup(feature.properties.ward_name)
                }).addTo(map);
            }
            wardsLayer.clearLayers().addData({ type: "FeatureCollection", features: visible });
            loadedWardsBounds = bounds;
        }

        function updateHealthFacilities() {
            const zoom = map.getZoom();
            if (zoom <= 11) {
                healthFacilitiesLayer?.clearLayers();
                loadedHealthBounds = null;
                return;
            }

            const bounds = map.getBounds();
            if (loadedHealthBounds && loadedHealthBounds.contains(bounds)) return;

            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
            const visible = facilitiesIndex.search({ minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3] })
                .map(item => item.feature);

            if (!healthFacilitiesLayer) {
                healthFacilitiesLayer = L.markerClusterGroup({ maxClusterRadius: 40 }).addTo(map);
            }
            healthFacilitiesLayer.clearLayers().addLayers(visible.map(f =>
                L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]])
                    .bindPopup(`<b>${f.properties.name}</b><br>Ward: ${f.properties.ward_name}`)
            ));

            loadedHealthBounds = bounds;
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Map Operation Functions
        function clearOA() {
            oaLangLats = [];
            drawnItems.clearLayers();
            enableOrDisableHtmlAttribute("run-clustering", true);
            enableOrDisableHtmlAttribute("get-grids", true);
            clearClusters(true);
            enableOrDisableHtmlAttribute("clear-oa", true);
            enableOrDisableHtmlAttribute("downloadOaWkt", true);
            $('#uploaded-file-name').text('No File Chosen');
        }

        function clearClusters(clearBuildings) {
            if (clearBuildings) {
                buildingsLayer.clearLayers();
                $('#building-count').text(0);
            }
            clusterLayer.clearLayers();
            resetFields();
            enableOrDisableHtmlAttribute("clear-clusters", true);
            enableOrDisableHtmlAttribute("get-grids", true);
            clearGrids();
            $('#cluster-count-val').text(0);
        }

        function clearGrids() {
            gridsDataExists = false;
            densityLayer.clearLayers();
            enableOrDisableHtmlAttribute("clear-grids", true);
            enableOrDisableHtmlAttribute("download-csv", !gridsDataExists);
            enableOrDisableHtmlAttribute("download-csv-commcare", !gridsDataExists);
            $('#grid-details').attr('hidden', true);
            processedData = { clusters: [], grids: [], buildings: [] };
            reSizeMap(mapDefaultHeight, true);
        }

        function resetFields() {
            gridsDataExists = false;
            lastFetchedData = {};
            gridAssignments = new Map();
            gridsData = {};
            processedData = { clusters: [], grids: [], buildings: [] };
        }

        function addOrUpdatePolygon(layer) {
            clearOA();
            isDrawing = false;

            const latlngs = layer.getLatLngs()[0].map(coord => [coord.lat, coord.lng]);
            latlngs.push(latlngs[0]); // Close the loop

            const polygonLayer = L.polygon(latlngs, { color: 'blue', weight: 1, fillOpacity: 0 }).addTo(drawnItems);
            map.fitBounds(polygonLayer.getBounds());
            oaLangLats = layer.getLatLngs()[0].map(coord => [coord.lng, coord.lat]);
            enableOrDisableHtmlAttribute("run-clustering", false);
            enableOrDisableHtmlAttribute("clear-oa", false);
            enableOrDisableHtmlAttribute("downloadOaWkt", false);
            fetchData(oaLangLats, null, false);
        }

        function addBuildings(data) {
            buildingsLayer.clearLayers();
            if (!data.buildings) return;
            L.geoJSON(data.buildings, {
                style: (feature) => ({
                    color: getColorForNumber(feature?.properties?.cluster_label),
                    weight: 1,
                    fillColor: getColorForNumber(feature.properties.cluster_label),
                    fillOpacity: 0.9
                }),
            }).addTo(buildingsLayer);
        }

        function addClusters(data, interactive) {
            clusterLayer.clearLayers();
            if (!data.clusters) return;

            const clusterGroups = groupClusters(data.clusters);
            let noOfClusters = 0;
            const clusters = Object.entries(clusterGroups).filter(([_, { points }]) => points.length > 2);

            clusters.forEach(([clusterId, { points }]) => {
                const boundary = turf.convex(turf.featureCollection(points.map(p => turf.point(p))));
                if (boundary) {
                    const color = getColorForNumber(parseInt(clusterId));
                    const boundaryLayer = L.geoJSON(boundary, { color, fillOpacity: 0, interactive: interactive });
                    boundaryLayer.bindTooltip(`Service Area ${parseInt(clusterId) + 1} \n Number of Buildings: ${points.length}`, {
                        sticky: true,
                        direction: 'auto',
                        opacity: 0.9
                    });
                    clusterLayer.addLayer(boundaryLayer);
                    noOfClusters++;
                }
            });

            $('#cluster-count-val').text(noOfClusters);
        }

        function reSizeMap(mapHeight, hideGrids) {
            const mapElement = $('#map')[0];
            mapElement.style.height = mapHeight;
            mapElement.style.transition = 'height 0.3s ease';
            setTimeout(() => map.invalidateSize(), 50);
            $('#grid-details').attr('hidden', hideGrids);
        }

        function drawGrids(lastFetchedData) {
            let data = JSON.parse(JSON.stringify(lastFetchedData));
            if (!data?.clusters || !data?.buildings) return;

            densityLayer.clearLayers();
            drawnGrids = [];
            processedData = { clusters: [], grids: [], buildings: [] };
            const assignedBuildings = new Set();
            const allBuildings = turf.featureCollection(data.clusters.map(c => turf.point(c.coordinates)));

            let clusterGroups = groupClusters(data.clusters);
            const boundaries = computeBoundaries(clusterGroups);

            const bbox = getExpandedBbox(allBuildings, 0.005);
            const gridSizeDeg = (parseInt($('#gridLength').val()) || 50) / 111000;
            const grid = turf.squareGrid(bbox, gridSizeDeg, { units: 'degrees' });

            const assignedBuildingIndices = new Set();
            turf.featureEach(grid, (currentGrid, gridIndex) => {
                const buildingsInGrid = getBuildingsInGrid(allBuildings, currentGrid, assignedBuildingIndices);
                const majorityCluster = findMajorityCluster(currentGrid, boundaries);
                if (!majorityCluster) return;

                gridAssignments.set(gridIndex, { clusterId: majorityCluster });
                currentGrid.cluster = majorityCluster;
                const hasBuildings = buildingsInGrid.features.length > 0;
                const gridBuildingsCount = buildingsInGrid.features.length;

                if (hasBuildings) {
                    reassignAndDrawBuildings(buildingsInGrid, majorityCluster, data, assignedBuildings);
                }

                const color = getColorForNumber(parseInt(majorityCluster));
                const gridLayer = L.geoJSON(currentGrid, {
                    style: {
                        color: color,
                        weight: hasBuildings ? 1 : 0,
                        fillOpacity: hasBuildings ? 0.4 : 0,
                        opacity: hasBuildings ? 1 : 0
                    }
                });

                gridLayer.bindTooltip(() => {
                    return `Service Area ${parseInt(currentGrid.cluster) + 1} \n Number of Buildings: ${processedData.clusters.find(c => parseInt(c.clusterId) === parseInt(currentGrid.cluster))?.buildingCount || 0}`;
                }, {
                    sticky: true,
                    direction: 'auto',
                    opacity: 0.9
                });

                if (gridBuildingsCount > 0) {
                    currentGrid.buildingCount = gridBuildingsCount;
                    const gridIndexNum = drawnGrids.length + 1;
                    drawnGrids.push({ grid: currentGrid, layer: gridLayer });

                    const geometry = currentGrid.geometry;
                    const coords = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    const wkt = `POLYGON ((${coords}, ${geometry.coordinates[0][0][0]} ${geometry.coordinates[0][0][1]}))`;

                    processedData.grids.push({
                        gridWKT: wkt,
                        clusterId: majorityCluster,
                        buildingCount: gridBuildingsCount,
                        geoJSON: currentGrid
                    });

                    gridLayer.on('click', () => {
                        reSizeMap('70%', false);
                        selectedGridIndex = gridIndexNum - 1;
                        const currentGridData = drawnGrids[selectedGridIndex].grid;
                        const currentCluster = currentGridData.cluster;
                        const currentBuildingCount = currentGridData.buildingCount;
                        $('#grid-no').text(`Delivery Unit: ${gridIndexNum}`);
                        $('#cluster-no').text(`Service Area: ${parseInt(currentCluster) + 1}`);
                        $('#grid-buildings').text(`Buildings in the DUs: ${currentBuildingCount}`);
                        $('#grid-color').html(`Service Area Color: <span class="color-box" style="background-color: ${getColorForNumber(currentCluster)};"></span>`);
                        setGridNeigboursInDropdown(currentCluster, currentGridData, groupClusters(data.clusters));
                    });
                }
                densityLayer.addLayer(gridLayer);
            });

            clusterGroups = groupClusters(data.clusters);
            clusterLayer.clearLayers();
            let noOfClusters = 0;
            processedData.clusters = [];

            Object.entries(clusterGroups).forEach(([clusterId, { points }]) => {
                if (points.length > 2) {
                    const boundary = turf.convex(turf.featureCollection(points.map(p => turf.point(p))));
                    if (boundary) {
                        const color = getColorForNumber(parseInt(clusterId));
                        const boundaryLayer = L.geoJSON(boundary, { color, fillOpacity: 0.5, interactive: false });
                        boundaryLayer.bindTooltip(() => {
                            return `Service Area ${parseInt(clusterId) + 1} \n Number of Buildings: ${processedData.clusters.find(c => parseInt(c.clusterId) === parseInt(clusterId))?.buildingCount || points.length}`;
                        }, {
                            sticky: true,
                            direction: 'auto',
                            opacity: 0.9
                        });
                        noOfClusters++;

                        const coords = boundary.geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                        const wkt = `POLYGON ((${coords}, ${boundary.geometry.coordinates[0][0][0]} ${boundary.geometry.coordinates[0][0][1]}))`;
                        processedData.clusters.push({
                            clusterId,
                            boundaryWKT: wkt,
                            buildingCount: points.length
                        });
                    }
                }
            });
            $('#cluster-count-val').text(noOfClusters);

            data.buildings.features.forEach((feature, index) => {
                const geometry = feature.geometry;
                if (geometry && geometry.type === "Polygon" && Array.isArray(geometry.coordinates)) {
                    const coords = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    const wkt = `POLYGON ((${coords}, ${geometry.coordinates[0][0][0]} ${geometry.coordinates[0][0][1]}))`;
                    const clusterLabel = data.clusters[index]?.cluster ?? "Unassigned";
                    processedData.buildings.push({
                        buildingWKT: wkt,
                        clusterId: clusterLabel
                    });
                }
            });

            gridsData = data;
            gridsDataExists = true;
            enableOrDisableHtmlAttribute("clear-grids", false);
            enableOrDisableHtmlAttribute("download-csv", !gridsDataExists);
            enableOrDisableHtmlAttribute("download-csv-commcare", !gridsDataExists);
        }

        function reassignGridToCluster() {
            if (selectedGridIndex === null) {
                showToast("No grid selected for reassignment.", "warning", 3000, "#FFA500");
                return;
            }

            const newClusterId = parseInt($('#neighbor-clusters').val());
            const gridData = drawnGrids[selectedGridIndex];
            const grid = gridData.grid;
            const gridLayer = gridData.layer;
            const oldClusterId = parseInt(grid.cluster);

            if (newClusterId === oldClusterId) {
                showToast("Grid is already assigned to this cluster.", "info", 2000, "#ff9300");
                return;
            }

            grid.cluster = newClusterId;
            gridAssignments.set(selectedGridIndex, { clusterId: newClusterId });
            processedData.grids[selectedGridIndex].clusterId = newClusterId;

            const allBuildings = turf.featureCollection(gridsData.clusters.map(c => turf.point(c.coordinates)));
            const buildingsInGrid = turf.featureCollection(
                allBuildings.features.filter((point) => turf.booleanPointInPolygon(point, grid))
            );

            const buildingIndices = [];
            const seenBuildings = new Set();
            buildingsInGrid.features.forEach(point => {
                const buildingIndex = gridsData.clusters.findIndex(c =>
                    c.coordinates[0] === point.geometry.coordinates[0] &&
                    c.coordinates[1] === point.geometry.coordinates[1]
                );
                if (buildingIndex !== -1 && !seenBuildings.has(buildingIndex)) {
                    gridsData.clusters[buildingIndex].cluster = newClusterId;
                    gridsData.buildings.features[buildingIndex].properties.cluster_label = newClusterId;
                    processedData.buildings[buildingIndex].clusterId = newClusterId;
                    buildingIndices.push(buildingIndex);
                    seenBuildings.add(buildingIndex);
                }
            });

            const newColor = getColorForNumber(newClusterId);
            gridLayer.setStyle({ color: newColor, fillOpacity: 0.4 });

            buildingIndices.forEach(index => {
                const buildingFeature = gridsData.buildings.features[index];
                if (buildingFeature.leafletLayer) {
                    buildingsLayer.removeLayer(buildingFeature.leafletLayer);
                }
            });

            const buildingsToRedraw = turf.featureCollection(buildingIndices.map(index => gridsData.buildings.features[index]));
            L.geoJSON(buildingsToRedraw, {
                style: (feature) => ({
                    color: "black",
                    weight: 1,
                    fillColor: getColorForNumber(feature.properties.cluster_label),
                    fillOpacity: 0.9
                }),
                onEachFeature: (feature, layer) => {
                    const buildingIndex = gridsData.buildings.features.findIndex(f => f === feature);
                    if (buildingIndex !== -1) {
                        gridsData.buildings.features[buildingIndex].leafletLayer = layer;
                    }
                }
            }).addTo(buildingsLayer);

            const clusterGroups = groupClusters(gridsData.clusters);
            processedData.clusters = [];
            clusterLayer.clearLayers();
            let noOfClusters = 0;

            Object.entries(clusterGroups).forEach(([clusterId, { points }]) => {
                if (points.length > 2) {
                    const boundary = turf.convex(turf.featureCollection(points.map(p => turf.point(p))));
                    if (boundary) {
                        const color = getColorForNumber(parseInt(clusterId));
                        const boundaryLayer = L.geoJSON(boundary, { color, fillOpacity: 0.5, interactive: false });
                        boundaryLayer.bindTooltip(() => {
                            const clusterData = processedData.clusters.find(c => parseInt(c.clusterId) === parseInt(clusterId));
                            const updatedBuildingCount = clusterData ? clusterData.buildingCount : points.length;
                            return `Service Area ${parseInt(clusterId) + 1} \n Number of Buildings: ${updatedBuildingCount}`;
                        }, {
                            sticky: true,
                            direction: 'auto',
                            opacity: 0.9
                        });
                        noOfClusters++;

                        const coords = boundary.geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                        const wkt = `POLYGON ((${coords}, ${boundary.geometry.coordinates[0][0][0]} ${boundary.geometry.coordinates[0][0][1]}))`;
                        processedData.clusters.push({
                            clusterId,
                            boundaryWKT: wkt,
                            buildingCount: points.length
                        });
                    }
                }
            });
            $('#cluster-count-val').text(noOfClusters);

            setGridNeigboursInDropdown(newClusterId, grid, clusterGroups);

            $('#cluster-no').text(`Service Area: ${parseInt(newClusterId) + 1}`);
            $('#grid-color').html(`Service Area Color: <span class="color-box" style="background-color: ${newColor};"></span>`);

            gridLayer.on('click', () => {
                reSizeMap('70%', false);
                selectedGridIndex = selectedGridIndex;
                const currentGridData = drawnGrids[selectedGridIndex].grid;
                const currentCluster = currentGridData.cluster;
                const currentBuildingCount = currentGridData.buildingCount;
                $('#grid-no').text(`Delivery Unit: ${selectedGridIndex + 1}`);
                $('#cluster-no').text(`Service Area: ${parseInt(currentCluster) + 1}`);
                $('#grid-buildings').text(`Buildings in the DUs: ${currentBuildingCount}`);
                $('#grid-color').html(`Service Area Color: <span class="color-box" style="background-color: ${getColorForNumber(currentCluster)};"></span>`);
                setGridNeigboursInDropdown(currentCluster, currentGridData, clusterGroups);
            });

            densityLayer.removeLayer(gridLayer);
            densityLayer.addLayer(gridLayer);

            showToast(`Grid reassigned to Service Area ${parseInt(newClusterId) + 1}!`, "success", 2000, "#4CAF50");
        }

        function setGridNeigboursInDropdown(currentCluster, currentGridData, clusterGroups) {
            const boundaries = computeBoundaries(clusterGroups);
            const dropdown = $('#neighbor-clusters');
            dropdown.empty();

            const neighborClusters = new Set();
            const currentOption = $('<option>').val(currentCluster).text(`Service Area ${parseInt(currentCluster) + 1} (Current)`);
            dropdown.append(currentOption);
            neighborClusters.add(parseInt(currentCluster));

            Object.entries(boundaries).forEach(([clusterId, boundary]) => {
                if (turf.intersect(currentGridData, boundary)) {
                    neighborClusters.add(parseInt(clusterId));
                }
            });

            const gridBbox = turf.bbox(currentGridData);
            const gridWidth = gridBbox[2] - gridBbox[0];
            const gridHeight = gridBbox[3] - gridBbox[1];
            const adjacentOffsets = [
                { dx: -gridWidth, dy: 0 },
                { dx: gridWidth, dy: 0 },
                { dx: 0, dy: gridHeight },
                { dx: 0, dy: -gridHeight }
            ];

            adjacentOffsets.forEach(offset => {
                const adjacentGrid = turf.transformTranslate(
                    currentGridData,
                    Math.sqrt(offset.dx * offset.dx + offset.dy * offset.dy),
                    Math.atan2(offset.dy, offset.dx) * 180 / Math.PI,
                    { units: 'degrees' }
                );

                let assignedCluster = null;
                for (let i = 0; i < drawnGrids.length; i++) {
                    const drawnGrid = drawnGrids[i].grid;
                    if (turf.booleanEqual(adjacentGrid, drawnGrid)) {
                        assignedCluster = parseInt(drawnGrid.cluster);
                        break;
                    }
                }

                if (assignedCluster !== null) {
                    neighborClusters.add(assignedCluster);
                } else {
                    const majorityCluster = findMajorityCluster(adjacentGrid, boundaries);
                    if (majorityCluster !== null) {
                        neighborClusters.add(parseInt(majorityCluster));
                    }
                }
            });

            Array.from(neighborClusters)
                .filter(clusterId => clusterId !== parseInt(currentCluster))
                .sort((a, b) => a - b)
                .forEach(clusterId => {
                    const option = $('<option>').val(clusterId).text(`Service Area ${parseInt(clusterId) + 1}`);
                    dropdown.append(option);
                });
        }

        function groupClusters(clusters) {
            const clusterGroups = {};
            clusters.forEach((feature, index) => {
                const { cluster, coordinates } = feature;
                if (!clusterGroups[cluster]) {
                    clusterGroups[cluster] = { points: [], indices: [] };
                }
                clusterGroups[cluster].points.push(coordinates);
                clusterGroups[cluster].indices.push(index);
            });
            return clusterGroups;
        }

        function computeBoundaries(clusterGroups) {
            const boundaries = {};
            Object.entries(clusterGroups).forEach(([clusterId, { points }]) => {
                if (points.length > 2) {
                    const turfPoints = points.map(p => turf.point(p));
                    const featureCollection = turf.featureCollection(turfPoints);
                    boundaries[clusterId] = turf.convex(featureCollection);
                }
            });
            return boundaries;
        }

        function getExpandedBbox(featureCollection, buffer) {
            const bbox = turf.bbox(featureCollection);
            return [bbox[0] - buffer, bbox[1] - buffer, bbox[2] + buffer, bbox[3] + buffer];
        }

        function getBuildingsInGrid(allBuildings, grid, assignedBuildingIndices) {
            return turf.featureCollection(
                allBuildings.features.filter((point, buildingIndex) => {
                    if (turf.booleanPointInPolygon(point, grid)) {
                        assignedBuildingIndices.add(buildingIndex);
                        return true;
                    }
                    return false;
                })
            );
        }

        function findMajorityCluster(grid, boundaries) {
            const intersectingClusters = [];
            Object.entries(boundaries).forEach(([clusterId, boundary]) => {
                const intersection = turf.intersect(grid, boundary);
                if (intersection) {
                    const area = turf.area(intersection);
                    intersectingClusters.push({ clusterId, area });
                }
            });
            if (intersectingClusters.length === 0) return null;
            intersectingClusters.sort((a, b) => b.area - a.area);
            return intersectingClusters[0].clusterId;
        }

        function reassignAndDrawBuildings(buildingsInGrid, majorityCluster, data, assignedBuildings) {
            const buildingsToDraw = [];
            buildingsInGrid.features.forEach(point => {
                const buildingIndex = data.clusters.findIndex(c =>
                    c.coordinates[0] === point.geometry.coordinates[0] &&
                    c.coordinates[1] === point.geometry.coordinates[1]
                );
                if (buildingIndex === -1) return;

                const coordKey = `${data.clusters[buildingIndex].coordinates[0]},${data.clusters[buildingIndex].coordinates[1]}`;
                if (assignedBuildings.has(coordKey)) return;

                data.clusters[buildingIndex].cluster = parseInt(majorityCluster);
                assignedBuildings.add(coordKey);

                const buildingFeature = data.buildings.features[buildingIndex];
                if (buildingFeature) {
                    buildingFeature.properties.cluster_label = parseInt(majorityCluster);
                    buildingsToDraw.push(buildingFeature);
                }
            });

            if (buildingsToDraw.length > 0) {
                const buildingsGeoJSON = turf.featureCollection(buildingsToDraw);
                L.geoJSON(buildingsGeoJSON, {
                    style: (feature) => ({
                        color: 'black',
                        weight: 1,
                        fillColor: getColorForNumber(feature.properties.cluster_label),
                        fillOpacity: 0.9
                    }),
                    onEachFeature: (feature, layer) => {
                        const buildingIndex = data.buildings.features.findIndex(f => f === feature);
                        if (buildingIndex !== -1) {
                            data.buildings.features[buildingIndex].leafletLayer = layer;
                        }
                    }
                }).addTo(buildingsLayer);
            }
        }

        function downloadGmapData(data) {
            if (!processedData.clusters.length && !processedData.grids.length && !processedData.buildings.length) {
                console.error("No processed data available for download");
                return;
            }

            let clusterCsvContent = "WKT,name,description\n";
            processedData.clusters.forEach(cluster => {
                clusterCsvContent += `"${cluster.boundaryWKT}",SA ${parseInt(cluster.clusterId) + 1},${cluster.buildingCount} buildings\n`;
            });

            processedData.grids.forEach((grid, index) => {
                if (grid.buildingCount > 0) {
                    clusterCsvContent += `"${grid.gridWKT}",DU ${index + 1},${grid.buildingCount} buildings\n`;
                }
            });

            let buildingsCsvContent = "WKT,name,description\n";
            processedData.buildings.forEach((building, index) => {
                buildingsCsvContent += `"${building.buildingWKT}",Building ${index + 1},SA: ${parseInt(building.clusterId) + 1}\n`;
            });

            downloadCsv(clusterCsvContent, 'service_area_&_delivery_units.csv');
            downloadCsv(buildingsCsvContent, 'buildings.csv');
            showToast("CSV downloaded! Import into Google My Maps at mymaps.google.com.", "success", 3000, "#00FF00");
        }

        function downloadCsvForCommCare(data, gridAssignments) {
            if (!processedData.grids.length) {
                console.error("No processed grid data available for CommCare CSV download");
                return;
            }

            let csvContent = "name,delivery_target,delivery_count,radius,centroid,bounding_box,service_area,flw,WKT,distance between adj sides 1,distance between adj sides 2,#Buildings,Surface Area (sq. meters)\n";
            processedData.grids.forEach((grid, index) => {
                if (grid.buildingCount === 0) return;

                const geometry = grid.geoJSON.geometry;
                const bbox = turf.bbox(grid.geoJSON);
                const widthDeg = bbox[2] - bbox[0];
                const heightDeg = bbox[3] - bbox[1];
                const widthMeters = widthDeg * 111000 * Math.cos(turf.centroid(grid.geoJSON).geometry.coordinates[1] * Math.PI / 180);
                const heightMeters = heightDeg * 111000;
                const diagonal = Math.sqrt(widthMeters * widthMeters + heightMeters * heightMeters);
                const radius = diagonal / 2;
                const centroid = turf.centroid(grid.geoJSON).geometry.coordinates;
                const centroidStr = `${centroid[1]} ${centroid[0]}`;
                const boundingBox = geometry.coordinates[0].map(coord => `${coord[1]} ${coord[0]}`).join(' ');
                const surfaceArea = turf.area(grid.geoJSON);

                const gridName = `Delivery Unit ${index + 1}`;
                const deliveryTarget = 1, deliveryCount = 0;
                csvContent += `"${gridName}",${deliveryTarget},${deliveryCount},${radius},"${centroidStr}",${boundingBox},${grid.clusterId},"","${grid.gridWKT}",${widthMeters},${heightMeters},${grid.buildingCount},${surfaceArea}\n`;
            });

            downloadCsv(csvContent, 'csv_for_CommCare.csv');
            showToast("CommCare CSV downloaded!", "success", 3000, "#00FF00");
        }

        function downloadSampleCsv() {
            const clusterCsvContent = `LLO Name,Total Area\n"Test LLO","POLYGON ((13.1623186 11.8734809, 13.1623186 11.8605101, 13.1755186 11.8605101, 13.1755186 11.8734809, 13.1623186 11.8734809))"`;
            downloadCsv(clusterCsvContent, 'sample_csv_file.csv');
        }

        function downloadCsv(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function uploadCSVPolygon() {
            clearOA();
            const fileInput = $('#csvUpload')[0];
            const file = fileInput.files[0];
            if (!file) return showToast("Please select a CSV file.", "warning", 3000, "#FFA500");

            const reader = new FileReader();
            reader.onload = function (event) {
                try {
                    const rows = event.target.result.split('\n').filter(row => row.trim());
                    if (rows.length < 2) throw new Error("CSV has no data rows.");

                    const parseCSVRow = row => {
                        const fields = [];
                        let inQuotes = false, field = '';
                        for (let char of row) {
                            if (char === '"') inQuotes = !inQuotes;
                            else if (char === ',' && !inQuotes) {
                                fields.push(field.trim());
                                field = '';
                            } else field += char;
                        }
                        fields.push(field.trim());
                        return fields;
                    };

                    const [header, firstDataRow] = [parseCSVRow(rows[0]), parseCSVRow(rows[1])];
                    if (firstDataRow.length < 2) throw new Error("CSV row lacks sufficient columns.");

                    const wktString = firstDataRow[1];
                    if (!wktString.match(/^POLYGON \(\(.*\)\)$/)) throw new Error("Invalid WKT format in CSV.");

                    const coordsStr = wktString.match(/POLYGON \(\((.*?)\)\)/)?.[1];
                    if (!coordsStr) throw new Error("Could not parse POLYGON coordinates.");

                    const latLngs = coordsStr.split(', ').map(coord => {
                        const [lon, lat] = coord.split(' ').map(Number);
                        if (isNaN(lon) || isNaN(lat)) throw new Error("Invalid coordinate values.");
                        return [lat, lon];
                    });

                    const mockLayer = {
                        getLatLngs: () => [latLngs.map(([lat, lng]) => ({ lat, lng }))],
                        getBounds: () => L.latLngBounds(latLngs)
                    };

                    showToast("OA loaded from CSV!", "success", 2000, "#4CAF50");
                    $('#uploaded-file-name').text(file.name);
                    addOrUpdatePolygon(mockLayer);
                } catch (error) {
                    showToast(`Error: ${error.message}`, "error", 3000, "#FF0000");
                    $('#uploaded-file-name').text('No File Chosen');
                } finally {
                    fileInput.value = '';
                }
            };
            reader.onerror = () => showToast("Error reading CSV file.", "error", 3000, "#FF0000");
            reader.readAsText(file);
        }

        function validateClusteringInputs(clusteringType, pinLatLng, polygon) {
            const showWarning = (message) => {
                showToast(message, "warning", 3000, "#FFA500");
                $('#run-clustering, #clear-oa, #downloadOaWkt').prop('disabled', false);
            };

            if (clusteringType === "bottomUp" && !pinLatLng) {
                showWarning("Please drop a pin on the map first.");
                return false;
            }

            if (clusteringType !== "bottomUp" && (!polygon || polygon.length === 0)) {
                showWarning("Please draw a polygon on the map first.");
                return false;
            }

            return true;
        }

        function fetchData(polygon, pinLatLng, fetchClusters) {
            clearClusters(!fetchClusters);
            enableOrDisableHtmlAttribute("clear-clusters", true);
            enableOrDisableHtmlAttribute("run-clustering", true);
            enableOrDisableHtmlAttribute("clear-oa", true);
            enableOrDisableHtmlAttribute("downloadOaWkt", true);
            enableOrDisableHtmlAttribute("download-csv", !gridsDataExists);
            enableOrDisableHtmlAttribute("download-csv-commcare", !gridsDataExists);

            let thresholdVal = $('#thresholdVal').val() || 0.5;
            if (thresholdVal > 100) thresholdVal = 100;
            if (thresholdVal < 0) thresholdVal = 0;
            const clusteringType = $('#clusteringType').val();
            let noOfClusters = $('#noOfClusters').val();
            if (noOfClusters <= 0) noOfClusters = 1;
            let noOfBuildings = $('#noOfBuildings').val();
            if (noOfBuildings <= 0) noOfBuildings = 1;
            const gridLength = $('#gridLength').val();

            if (!validateClusteringInputs(clusteringType, pinLatLng, polygon)) {
                return;
            }

            const requestBody = {
                pin: pinLatLng,
                polygon,
                clusteringType,
                noOfClusters,
                noOfBuildings,
                gridLength,
                thresholdVal,
                fetchClusters
            };

            showToast('Fetching data...', 'info', undefined, '#ff9300');

            fetch(`${hostUrl}/get_building_density`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            })
                .then(response => {
                    if (fetchClusters) {
                        enableOrDisableHtmlAttribute("clear-clusters", false);
                    }
                    enableOrDisableHtmlAttribute("clear-oa", false);
                    enableOrDisableHtmlAttribute("downloadOaWkt", false);
                    enableOrDisableHtmlAttribute("run-clustering", false);
                    return response.json();
                })
                .then(data => {
                    Swal.close();
                    if (data.error) {
                        showToast(`Error: ${data.error}`, 'error', 5000, '#FF0000', '300px');
                    } else {
                        showToast('Data loaded!', 'success', 2000, '#4CAF50');
                        $('#building-count').text(data.building_count ?? "Error fetching data");
                        if (data.building_count == 0) showToast(`No Buildings in the OA`, 'error', 5000, '#FF0000', '300px');
                        lastFetchedData = data;
                        addBuildings(data);
                        if (fetchClusters) {
                            addClusters(data, true);
                            enableOrDisableHtmlAttribute("get-grids", false);
                        }
                    }
                })
                .catch(error => {
                    Swal.close();
                    showToast(`Error: ${error.message}`, 'error', 5000, '#FF0000', '300px');
                    console.error('Error:', error);
                    $('#building-count').text("Error fetching data");
                    enableOrDisableHtmlAttribute("clear-clusters", false);
                    enableOrDisableHtmlAttribute("clear-oa", false);
                    enableOrDisableHtmlAttribute("downloadOaWkt", false);
                });
        }

        function downloadOAWkt() {
            if (!oaLangLats || oaLangLats.length === 0) {
                showToast("No OA drawn to download.", "warning", 3000, "#FFA500");
                return;
            }

            const coordsStr = oaLangLats.map(coord => `${coord[0]} ${coord[1]}`).join(', ');
            const wkt = `POLYGON ((${coordsStr}))`;
            const csvContent = `OA Wkt\n"${wkt}"`;
            downloadCsv(csvContent, 'oa_wkt.csv');
            showToast("OA WKT downloaded!", "success", 2000, "#4CAF50");
        }

        // Initialize
        $(document).ready(function () {
            toggleInputFields();
        });
        function toggleSidebar() {
            const $rightPanel = $('#right-panel');
            const $leftPanel = $('#left-panel');
            const $toggleBtn = $('#sidebar-toggle-btn i');
            if ($rightPanel.hasClass('collapsed')) {
                $rightPanel.removeClass('collapsed');
                $leftPanel.removeClass('expanded');
                $toggleBtn.removeClass('bi-chevron-left').addClass('bi-chevron-right');
                $('#sidebar-toggle-btn').attr('title', 'Collapse Sidebar');
            } else {
                $rightPanel.addClass('collapsed');
                $leftPanel.addClass('expanded');
                $toggleBtn.removeClass('bi-chevron-right').addClass('bi-chevron-left');
                $('#sidebar-toggle-btn').attr('title', 'Expand Sidebar');
            }
            setTimeout(() => map.invalidateSize(), 300);
        }

        // Initialize
        $(document).ready(function () {
            toggleInputFields();
            $('#sidebar-toggle-btn').on('click', toggleSidebar);
        });
    </script>
</body>
</html>