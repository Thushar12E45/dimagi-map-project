<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Density Clustering</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

    <!-- Leaflet and related libraries -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css"/>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css"/>
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <!-- Other libraries -->
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/6.5.0/turf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- jQuery and Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.min.js" integrity="sha384-0pUGZvbkm6XF6gxjEnlmuGrJXVbNuzT9qBBavbLwCsOGabYfZo0T0to5eqruptLy" crossorigin="anonymous"></script>

    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            height: 100vh;
            overflow: hidden;
        }

        #map {
            height: 100%;
            width: 100%;
        }

        #container {
            display: flex;
            height: 95vh;
            width: 100vw;
        }

        #left-panel {
            flex: 3;
            padding: 10px;
            position: relative; /* For absolute positioning of button */
            transition: flex 0.3s ease;
        }
        #left-panel.expanded {
            flex: 1 1 100%; /* Expand to full width when sidebar is collapsed */
        }

        #right-panel {
            width: 27vw;
            padding: 10px;
            background-color: #f5f5f5;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        #right-panel.collapsed {
            width: 0;
            transform: translateX(100%);
            padding: 0;
        }

        .card {
            margin-bottom: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .card-body {
            padding: 15px;
        }

        .btn {
            padding: 10px;
            font-size: 14px;
        }

        .color-box {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 1px solid #999;
            border-radius: 4px;
            margin-left: 10px;
        }

        #grid-details {
            height: 30%;
            overflow-y: auto;
        }

        .cursor-pointer {
            cursor: pointer;
            font-size: 18px;
            color: #555;
        }
        #sidebar-toggle-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            z-index: 1000;
            font-size: 20px;
            background: #fff; /* White background */
            border: 1px solid #ccc; /* Subtle border for definition */
            border-radius: 50%; /* Circular shape */
            width: 34px; /* Fixed width for circle */
            height: 34px; /* Fixed height for circle */
            color: #333;
            padding: 0; /* Remove padding to center icon */
            display: flex;
            align-items: center;
            justify-content: center; /* Center the icon */
            transition: color 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease; /* Added shadow transition */
        }

        #sidebar-toggle-btn:hover {
            color: #007bff;
            transform: scale(1.1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2); /* Subtle shadow on hover */
        }
        .card-text {
            margin-bottom: 2px !important 
        }
        .download-container {
            position: relative;
        }

        .download-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            width: 100%;
        }

        .download-option {
            display: block;
            width: 100%;
            padding: 10px;
            border: none;
            background: #fff;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
        }

        .download-option:hover {
            background: #f0f0f0;
        }

    </style>
</head>
<body>
    <div class="container-fluid p-0">
        <h3 class="mb-0 ms-3">Building Density Clustering</h3>
        <div id="container">
            <div id="left-panel">
                <button id="sidebar-toggle-btn" title="Toggle Sidebar">
                    <i class="bi bi-chevron-right"></i> <!-- Hamburger icon by default -->
                </button>
                <div id="map" class="mb-3"></div>
                <div id="grid-details" class="card" hidden>
                    <div class="card-body">
                        <h5 class="card-title">Delivery Unit Details <span id="close-grid-details" class="float-end cursor-pointer">Ã—</span></h5>
                        <p id="grid-no" class="card-text">Grid No: None</p>
                        <p id="oa-no" class="card-text">OA: None</p>
                        <p id="cluster-no" class="card-text">Cluster No: None</p>
                        <p id="grid-color" class="card-text">Cluster Color: <span class="color-box" style="background-color: transparent;"></span></p>
                        <p id="grid-buildings" class="card-text">Buildings in the Grid: 0</p>
                        <div class="mb-1" style="width: 30%;">
                            <label for="neighbor-clusters" class="form-label">Reassign to Cluster:</label>
                            <div class="input-group">
                                <select class="form-select" id="neighbor-clusters"></select>
                                <button class="btn btn-success" id="reassign-cluster" onclick="reassignGridToCluster()">Reassign</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div id="right-panel">
                <!-- CSV Operations -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">CSV Operations</h5>
                        <div class="row g-2">
                            <div class="col-6">
                                <input type="text" id="csvDownload" class="d-none" onclick="downloadSampleCsv()">
                                <label for="csvDownload" class="btn btn-secondary w-100">Download Sample CSV</label>
                            </div>
                            <div class="col-6">
                                <input type="file" id="csvUpload" accept=".csv" class="d-none" onchange="uploadCSVPolygon()">
                                <label for="csvUpload" class="btn btn-success w-100">Upload CSV</label>
                            </div>
                        </div>
                        <span id="uploaded-file-name" class="d-block text-muted mt-2">No File Chosen</span>
                    </div>
                </div>

                <!-- Area Details -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Oppurtunity Area Details</h5>
                        <div class="mb-3">
                            <label for="polygonSelect" class="form-label">Select OA:</label>
                            <select class="form-select" id="polygonSelect" onchange="updateSelectedPolygon()">
                                <option value="-1" selected>No OA Selected</option>
                            </select>
                        </div>
                        <p id="info">Total Buildings: <span id="total-building-count">0</span></p>
                        <p id="info">Buildings in selected OA: <span id="building-count">0</span></p>
                        <p id="clusterCount">Service Areas Created: <span id="cluster-count-val">0</span></p>
                    </div>
                </div>

                <!-- Clustering Settings -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Clustering Settings</h5>
                        <div class="mb-3">
                            <label for="DBtype" class="form-label">Fetch Buildings From:</label>
                            <select class="form-select" id="DBtype">
                                <option value="GEE">Google Earth Engine (GEE)</option>
                                <option value="psql">Postgres Data Base</option>
                            </select>
                        </div>
                        <div class="mb-3">
                            <label for="clusteringType" class="form-label">Select Service Area Grouping Method:</label>
                            <select class="form-select" id="clusteringType" onchange="toggleInputFields()">
                                <option value="kMeans">K-Means Clustering</option>
                                <option value="balancedKMeans">Balanced K Means</option>
                                <option value="bottomUp">Bottom-Up Approach</option>
                            </select>
                        </div>
                        <div id="noOfClustersIP" class="mb-3 d-none">
                            <label for="noOfClusters" class="form-label">Number of Service Areas:</label>
                            <input type="number" class="form-control" id="noOfClusters" min="1" value="3">
                        </div>
                        <div id="noOfBuildingsIP" class="mb-3 d-none">
                            <label for="noOfBuildings" class="form-label">No of Buildings:</label>
                            <input type="number" class="form-control" id="noOfBuildings" value="250">
                        </div>
                        <div id="thresholdValueIP" class="mb-3 d-none">
                            <label for="thresholdVal" class="form-label">Tolerance Value as %:</label>
                            <input type="number" class="form-control" id="thresholdVal" step="0.01" value="10" min="0" max="100">
                        </div>
                        <div class="mb-3">
                            <label for="gridLength" class="form-label">Delivery Unit Length in metres:</label>
                            <input type="number" class="form-control" id="gridLength" step="0.01" value="50">
                        </div>
                    </div>
                </div>

                <!-- Actions -->
                <div class="card">
                    <div class="card-body">
                        <h5 class="card-title">Actions</h5>
                        <div class="row g-2">
                            <div class="col-6">
                                <button class="btn btn-success w-100" id="run-clustering" disabled>Get Service Areas</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-warning w-100" onclick="clearClusters(false)" id="clear-clusters" disabled>Clear Service Areas</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-success w-100" id="get-grids" disabled>Get Delivery Units</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-warning w-100" addClusters(lastFetchedData, true) id="clear-grids" disabled>Clear Delivery Units</button>
                            </div>
                            <div class="col-6">
                                <button class="btn btn-danger w-100" onclick="clearOA()" id="clear-oa" disabled>Clear Map</button>
                            </div>
                            <div class="col-6">
                                <div class="download-container">
                                    <button class="btn btn-primary w-100" id="download-btn" disabled>Download <span>â–¼</span></button>
                                    <div id="download-menu" class="download-menu" style="display: none;">
                                        <button id="download-oa-wkt" class="download-option">Download OA WKT</button>
                                        <button id="download-csv-my-maps" class="download-option">Download CSV for My Maps</button>
                                        <button id="download-csv-commcare" class="download-option">Download CSV for CommCare</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Constants and Global Variables
        let hostUrl = "{{ host_url }}";
        // hostUrl = "http://localhost:5000"
        let uploadedReportData = null;
        let polygons = [];
        let selectedPolygonIndex = -1;
        let pinLatLng = null;
        let mapDefaultHeight = '100%';

        const defaultPolygonStyle = {
            color: '#3388ff', // Blue outline
            weight: 1,
            fillOpacity: 0,
        };

        const highlightPolygonStyle = {
            fillOpacity: 0.1
        };

        // Map Setup
        const map = L.map('map').setView([9.082, 8.6753], 6);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
        }).addTo(map);

        const blackMarkerIcon = L.icon({
            iconUrl: 'https://cdn.jsdelivr.net/gh/pointhi/leaflet-color-markers@master/img/marker-icon-black.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        const drawnItems = new L.FeatureGroup().addTo(map);
        const drawControl = new L.Control.Draw({
            draw: { polygon: true, rectangle: true, polyline: false, circle: false, marker: { icon: blackMarkerIcon } },
            edit: { featureGroup: drawnItems }
        }).addTo(map);

        const polygonLayers = new Map();
        // Wards and Facilities Setup
        const wardsIndex = new RBush();
        const facilitiesIndex = new RBush();
        let wardsLayer = null, healthFacilitiesLayer = null;
        let loadedWardsBounds = null, loadedHealthBounds = null;

        Promise.all([
            fetch('/static/nigeria_ward.geojson').then(r => r.json()),
            fetch('/static/nigeria_health_facilities.geojson').then(r => r.json())
        ]).then(([wardsData, facilitiesData]) => {
            setupIndex(wardsData, wardsIndex, 'polygon');
            setupIndex(facilitiesData, facilitiesIndex, 'point');
            updateMapLayers();
        });

        const updateMapLayers = debounce(() => {
            updateWards();
            updateHealthFacilities();
        }, 200);
        map.on('zoomend moveend', updateMapLayers);

        // Draw Events
        let isDrawing = false;
        map.on(L.Draw.Event.DRAWSTART, () => {
            isDrawing = true;
        });

        function handleLayerEvent(layer, layerType = null) {
            if (layerType === 'marker' || layer instanceof L.Marker) {
                pinLatLng = [layer.getLatLng().lng, layer.getLatLng().lat];
                drawnItems.addLayer(layer);
                map.panTo(layer.getLatLng());
                $('#run-clustering, #clear-oa, #download-oa-wkt').prop('disabled', false);
                polygons = [];
                updatePolygonDropdown()
            } else if (layerType === 'polygon' || layerType === 'rectangle' || layer instanceof L.Polygon) {
                addOrUpdatePolygon(layer);
                pinLatLng = null;
            }
        }

        map.on(L.Draw.Event.CREATED, (event) => handleLayerEvent(event.layer, event.layerType));
        map.on(L.Draw.Event.EDITED, (event) => {
            event.layers.eachLayer(layer => {
                const index = polygons.findIndex(p => p.layer === layer);
                if (index === -1) {
                    showToast("Edited polygon not found in the list. Please re-draw the polygon.", "warning", 3000, "#FFA500");
                    return;
                }
                clearClusters(index, true)
                if (drawnItems.hasLayer(layer)) {
                    drawnItems.removeLayer(layer);
                }
                if (map.hasLayer(layer)) {
                    map.removeLayer(layer);
                }
                addOrUpdatePolygon(layer, index)
            });
        });

        function updatePolygonDropdown() {
            const $select = $('#polygonSelect');
            $select.empty();
            $select.append('<option value="-1">No OA Selected</option>');
            polygons.forEach((polygon, index) => {
                $select.append(`<option value="${index}">OA ${index + 1}</option>`);
            });
            $select.val(selectedPolygonIndex);
        }

        function updateSelectedPolygon() {
            selectedPolygonIndex = parseInt($('#polygonSelect').val());
            const totalBuildingCount = polygons.reduce((sum, p) => sum + (p.buildingCount || 0), 0);
            if (selectedPolygonIndex !== -1) {
                const selectedPolygon = polygons[selectedPolygonIndex];
                $('#building-count').text(selectedPolygon.buildingCount ?? 0);
                $('#cluster-count-val').text(selectedPolygon.clusterCount ?? 0);
                $('#total-building-count').text(totalBuildingCount ?? 0);
                enableOrDisableHtmlAttribute("run-clustering", false);
                enableOrDisableHtmlAttribute("clear-oa", false);
                enableOrDisableHtmlAttribute("get-grids", selectedPolygon.clustersData ? false : true);
                enableOrDisableHtmlAttribute("clear-clusters", selectedPolygon.clustersData ? false : true);
                enableOrDisableHtmlAttribute("clear-grids", selectedPolygon.gridsDataExists ? false : true);

                // Simplified enabling/disabling logic for download options
                const polygonExists = true; // A polygon is selected
                const gridsExist = selectedPolygon.gridsDataExists;

                // Enable "Download OA WKT" if a polygon exists
                enableOrDisableHtmlAttribute("download-oa-wkt", !polygonExists);
                // Enable CSV downloads only if grids are drawn
                enableOrDisableHtmlAttribute("download-csv-my-maps", !gridsExist);
                enableOrDisableHtmlAttribute("download-csv-commcare", !gridsExist);
                // Enable the "Download" button if any option is available (i.e., if a polygon exists)
                enableOrDisableHtmlAttribute("download-btn", !polygonExists);
            } else {
                $('#building-count').text(0);
                $('#cluster-count-val').text(0);
                $('#total-building-count').text(0);
                enableOrDisableHtmlAttribute("run-clustering", true);
                enableOrDisableHtmlAttribute("clear-oa", true);
                enableOrDisableHtmlAttribute("get-grids", true);
                enableOrDisableHtmlAttribute("clear-clusters", true);
                enableOrDisableHtmlAttribute("clear-grids", true);

                // Disable all download options and the "Download" button
                enableOrDisableHtmlAttribute("download-oa-wkt", true);
                enableOrDisableHtmlAttribute("download-csv-my-maps", true);
                enableOrDisableHtmlAttribute("download-csv-commcare", true);
                enableOrDisableHtmlAttribute("download-btn", true);
            }
            highlightSelectedPolygon();
        }

        function highlightSelectedPolygon() {
            // Loop through all polygons to apply styles
            polygons.forEach((polygon, index) => {
                const layer = polygon.layer;
                if (!layer) {
                    console.warn(`Polygon at index ${index} has no layer.`);
                    return;
                }

                if (index === selectedPolygonIndex) {
                    // Highlight the selected polygon
                    layer.setStyle(highlightPolygonStyle);
                    // Optionally focus the map on the selected polygon
                    map.fitBounds(layer.getBounds(), { padding: [50, 50] });
                } else {
                    // Revert other polygons to the default style
                    layer.setStyle(defaultPolygonStyle);
                }
            });
        }

        // Utility Functions
        function showToast(title, icon, timer, background, width = '250px') {
            Swal.fire({
                toast: true,
                position: 'bottom-start',
                title,
                icon,
                showConfirmButton: false,
                timer,
                width,
                padding: '5px',
                background,
                color: '#FFFFFF'
            });
        }

        function getColorForNumber(num) {
            if (num == null || num == undefined) return "black";
            const hue = (num * 137) % 360;
            return `hsl(${hue}, 90%, 50%)`;
        }

        function enableOrDisableHtmlAttribute(id, value, attribute = 'disabled') {
            $('#' + id).prop(attribute, value);
        }

        function toggleInputFields() {
            const method = $('#clusteringType').val();
            $('#noOfClustersIP, #noOfBuildingsIP, #thresholdValueIP').addClass('d-none');
            $('#gridLengthIP, #thresholdValueIP').removeClass('d-none');

            if (method === "kMeans") {
                $('#noOfClustersIP').removeClass('d-none');
            } else if (method === "balancedKMeans") {
                $('#noOfBuildingsIP').removeClass('d-none');
            } else if (method === "bottomUp") {
                $('#noOfClustersIP, #noOfBuildingsIP').removeClass('d-none');
            }

            $('#close-grid-details').off('click').on('click', () => reSizeMap(mapDefaultHeight, true));
        }

        // Map Data Functions
        function setupIndex(data, index, type) {
            index.load(data.features.map(f => {
                const coords = f.geometry.coordinates;
                const [minLng, minLat, maxLng, maxLat] = type === 'point'
                    ? [coords[0], coords[1], coords[0], coords[1]]
                    : turf.bbox(f);
                return { minX: minLng, minY: minLat, maxX: maxLng, maxY: maxLat, feature: f };
            }));
        }

        function updateWards() {
            const zoom = map.getZoom();
            if (zoom <= 10) {
                wardsLayer?.clearLayers();
                loadedWardsBounds = null;
                return;
            }

            const bounds = map.getBounds();
            if (loadedWardsBounds && loadedWardsBounds.contains(bounds)) return;

            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
            const visible = wardsIndex.search({ minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3] })
                .map(item => item.feature);

            if (!wardsLayer) {
                wardsLayer = L.geoJson(null, {
                    style: { color: "black", weight: 1, fillOpacity: 0, dashArray: "4,4" },
                    interactive: false,
                    onEachFeature: (feature, layer) => layer.bindPopup(feature.properties.ward_name)
                }).addTo(map);
            }
            wardsLayer.clearLayers().addData({ type: "FeatureCollection", features: visible });
            loadedWardsBounds = bounds;
        }

        function updateHealthFacilities() {
            const zoom = map.getZoom();
            if (zoom <= 11) {
                healthFacilitiesLayer?.clearLayers();
                loadedHealthBounds = null;
                return;
            }

            const bounds = map.getBounds();
            if (loadedHealthBounds && loadedHealthBounds.contains(bounds)) return;

            const bbox = [bounds.getWest(), bounds.getSouth(), bounds.getEast(), bounds.getNorth()];
            const visible = facilitiesIndex.search({ minX: bbox[0], minY: bbox[1], maxX: bbox[2], maxY: bbox[3] })
                .map(item => item.feature);

            if (!healthFacilitiesLayer) {
                healthFacilitiesLayer = L.markerClusterGroup({ maxClusterRadius: 40 }).addTo(map);
            }
            healthFacilitiesLayer.clearLayers().addLayers(visible.map(f =>
                L.marker([f.geometry.coordinates[1], f.geometry.coordinates[0]])
                    .bindPopup(`<b>${f.properties.name}</b><br>Ward: ${f.properties.ward_name}`)
            ));

            loadedHealthBounds = bounds;
        }

        function debounce(func, wait) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, args), wait);
            };
        }

        // Map Operation Functions
        function clearOA() {
            polygons = [];
            polygonLayers.forEach(layers => {
                layers.buildingsLayer.remove();
                layers.clusterLayer.remove();
                layers.densityLayer.remove();
            });
            polygonLayers.clear();
            drawnItems.clearLayers();
            enableOrDisableHtmlAttribute("run-clustering", true);
            enableOrDisableHtmlAttribute("get-grids", true);
            enableOrDisableHtmlAttribute("clear-oa", true);
            enableOrDisableHtmlAttribute("download-oa-wkt", true);
            enableOrDisableHtmlAttribute("download-csv-my-maps", true);
            enableOrDisableHtmlAttribute("download-csv-commcare", true);
            enableOrDisableHtmlAttribute("download-btn", true);
            $('#uploaded-file-name').text('No File Chosen');
            updatePolygonDropdown();
            selectedPolygonIndex = -1;
            $('#building-count').text(0);
            $('#cluster-count-val').text(0);
        }

        function clearClusters(index, clearBuildings) {
            const polygonData = polygons[index];
            if (clearBuildings) {
                polygonData.buildingsLayer.clearLayers();
                polygonData.buildingCount = 0;
                $('#building-count').text(polygons.reduce((sum, p) => sum + (p.buildingCount || 0), 0));
            }
            polygonData.clusterLayer.clearLayers();
            polygonData.clustersData = null;
            polygonData.clusterCount = 0;
            enableOrDisableHtmlAttribute("clear-clusters", true);
            enableOrDisableHtmlAttribute("get-grids", true);
            clearGrids(index);
            $('#cluster-count-val').text(polygons.reduce((sum, p) => sum + (p.clusterCount || 0), 0));
        }

        function clearGrids(index) {
            const polygonData = polygons[index];
            polygonData.densityLayer.clearLayers();
            polygonData.gridsDataExists = false;
            enableOrDisableHtmlAttribute("clear-grids", true);
            enableOrDisableHtmlAttribute("download-csv-my-maps", true);
            enableOrDisableHtmlAttribute("download-csv-commcare", true);
            enableOrDisableHtmlAttribute("download-oa-wkt", false);
            enableOrDisableHtmlAttribute("download-btn", false);
            $('#grid-details').attr('hidden', true);
            polygonData.processedData = { clusters: new Map(), grids: new Map(), buildings: new Map() };
            reSizeMap(mapDefaultHeight, true);
        }

        function resetFields() {
            gridsDataExists = false;
            lastFetchedData = {};
            gridAssignments = new Map();
            gridsData = {};
            processedData = { clusters: new Map(), grids: new Map(), buildings: new Map() };
        }

        function addOrUpdatePolygon(layer, index=-1) {
            isDrawing = false;

            const latlngs = layer.getLatLngs()[0].map(coord => [coord.lng, coord.lat]);
            const polygonLayer = L.polygon(layer.getLatLngs(), { color: 'blue', weight: 1, fillOpacity: 0 }).addTo(drawnItems);
            map.fitBounds(polygonLayer.getBounds());
            // Create layers for this polygon and add them to the map
            const buildingsLayer = L.geoJSON(null, {
                style: () => ({ color: "black", weight: 1, fillOpacity: 0.9 })
            }).addTo(map);
            const clusterLayer = L.featureGroup().addTo(map);
            const densityLayer = L.geoJSON(null).addTo(map);

            const polygonData = {
                layer: polygonLayer,
                latlngs,
                buildingsLayer,
                clusterLayer,
                densityLayer,
                buildingCount: 0,
                clusterCount: 0,
                data: null,
                clustersData: null,
                gridsDataExists: false,
                processedData: { clusters: new Map(), grids: new Map(), buildings: new Map() },
                gridAssignments: new Map(),
                drawnGrids: []
            };
            if (index == -1) {
                index = polygons.length
            }
            polygons[index] = polygonData;
            polygonLayers.set(index, {
                buildingsLayer,
                clusterLayer,
                densityLayer
            });

            updatePolygonDropdown();

            // Automatically select the newly drawn polygon and fetch data
            selectedPolygonIndex = index;
            $('#polygonSelect').val(selectedPolygonIndex);
            fetchData(selectedPolygonIndex, latlngs, null, false);
        }

        function addBuildings(index, data) {
            const polygonData = polygons[index];
            const buildingsLayer = polygonData.buildingsLayer;
            buildingsLayer.clearLayers();
            if (!data.buildings) return;

            L.geoJSON(data.buildings, {
                style: (feature) => ({
                    color: getColorForNumber(feature?.properties?.clusterId),
                    weight: 1,
                    fillColor: getColorForNumber(feature.properties.clusterId),
                    fillOpacity: 0.9,
                    interactive: false
                }),
            }).addTo(buildingsLayer);
        }

        function addClusters(index, data, interactive) {
            const polygonData = polygons[index];
            const clusterLayer = polygonData.clusterLayer;
            clusterLayer.clearLayers();
            if (!data.clusters) return;

            const clusterGroups = groupClusters(data.clusters);
            let noOfClusters = 0;
            const clusters = Object.entries(clusterGroups).filter(([_, { points }]) => points.length > 2);

            clusters.forEach(([clusterId, { points }]) => {
                const boundary = turf.convex(turf.featureCollection(points.map(p => turf.point(p))));
                if (boundary) {
                    const color = getColorForNumber(parseInt(clusterId));
                    const boundaryLayer = L.geoJSON(boundary, { color, fillOpacity: 0, interactive: interactive });
                    boundaryLayer.bindTooltip(`Service Area ${parseInt(clusterId) + 1} \n Number of Buildings: ${points.length}`, {
                        sticky: true,
                        direction: 'auto',
                        opacity: 0.9
                    });
                    clusterLayer.addLayer(boundaryLayer);
                    noOfClusters++;
                }
            });

            polygonData.clusterCount = noOfClusters;
            $('#cluster-count-val').text(noOfClusters);
        }

        function generateSquareGrid(bbox, gridSizeDeg) {
            const [minX, minY, maxX, maxY] = bbox;
            const grids = [];
            const xSteps = Math.ceil((maxX - minX) / gridSizeDeg);
            const ySteps = Math.ceil((maxY - minY) / gridSizeDeg);

            for (let i = 0; i < xSteps; i++) {
                for (let j = 0; j < ySteps; j++) {
                    const x = minX + i * gridSizeDeg;
                    const y = minY + j * gridSizeDeg;
                    const grid = {
                        type: "Feature",
                        geometry: {
                            type: "Polygon",
                            coordinates: [[
                                [x, y],
                                [x + gridSizeDeg, y],
                                [x + gridSizeDeg, y + gridSizeDeg],
                                [x, y + gridSizeDeg],
                                [x, y]
                            ]]
                        },
                        properties: {}
                    };
                    grids.push(grid);
                }
            }
            return { type: "FeatureCollection", features: grids };
        }

        function createBuildingIndex(buildings) {
            const tree = new RBush();
            const items = buildings.features.map((feature, index) => {
                const [x, y] = feature.geometry.coordinates;
                return {
                    minX: x,
                    minY: y,
                    maxX: x,
                    maxY: y,
                    index
                };
            });
            tree.load(items);
            return tree;
        }

        function getBuildingsInGridFast(buildingIndex, buildings, grid, assignedBuildingIndices, clusterId) {
            const [minX, minY, maxX, maxY] = turf.bbox(grid);
            const overlapping = buildingIndex.search({ minX, minY, maxX, maxY });
            const features = overlapping
                .filter(item => !assignedBuildingIndices.has(item.index))
                .map(item => {
                    assignedBuildingIndices.add(item.index);
                    buildings.features[item.index].clusterId = clusterId;
                    return buildings.features[item.index];
                });
            return { type: "FeatureCollection", features };
        }

        function reSizeMap(mapHeight, hideGrids) {
            const mapElement = $('#map')[0];
            mapElement.style.height = mapHeight;
            mapElement.style.transition = 'height 0.3s ease';
            setTimeout(() => map.invalidateSize(), 50);
            $('#grid-details').attr('hidden', hideGrids);
        }

        function drawGrids(index, data) {

            const polygonData = polygons[index];
            const densityLayer = polygonData.densityLayer;
            densityLayer.clearLayers();

            const buildingLayer = polygonData.buildingsLayer;
            buildingLayer.clearLayers();

            polygonData.clusterLayer.clearLayers();
            const gridAssignments = new Map();
            const drawnGrids = [];
            // Use Maps instead of arrays for processedData
            const processedData = {
                clusters: new Map(), // Map<clusterId, { clusterId, buildingCount }>
                grids: new Map(),    // Map<gridIndex, { gridWKT, clusterId, buildingCount, geoJSON }>
                buildings: new Map() // Map<buildingIndex, { ... }>
            };
            const assignedBuildings = new Set();
            const allBuildings = turf.featureCollection(data.clusters.map(c => turf.point(c.coordinates)));

            // Precompute spatial index for buildings
            const buildingIndex = createBuildingIndex(allBuildings);

            // Precompute cluster groups and boundaries
            const clusterGroups = groupClusters(data.clusters);
            const boundaries = computeBoundaries(clusterGroups);

            // Generate grids efficiently
            const bbox = getExpandedBbox(allBuildings, 0.005);
            const gridSizeDeg = (parseInt($('#gridLength').val()) || 100) / 111000;
            const grid = generateSquareGrid(bbox, gridSizeDeg);

            // Batch all grid features for a single L.geoJSON call
            const gridFeatures = [];
            // const assignedBuildingIndices = new Set();
            grid.features.forEach((currentGrid, gridIndex) => {
                const majorityCluster = findMajorityCluster(currentGrid, boundaries);
                if (!majorityCluster) {
                    return;
                }
                const buildingsInGrid = getBuildingsInGridFast(buildingIndex, allBuildings, currentGrid, assignedBuildings);


                gridAssignments.set(gridIndex, { clusterId: majorityCluster });
                currentGrid.properties.cluster = majorityCluster;
                const hasBuildings = buildingsInGrid.features.length > 0;
                const gridBuildingsCount = buildingsInGrid.features.length;

                if (hasBuildings) {
                    reassignAndDrawBuildings(index, buildingsInGrid, majorityCluster, data, assignedBuildings, processedData, drawnGrids.length + 1);
                }

                const color = getColorForNumber(parseInt(majorityCluster));
                currentGrid.properties.style = {
                    color: color,
                    weight: hasBuildings ? 1 : 0,
                    fillOpacity: hasBuildings ? 0.4 : 0,
                    opacity: hasBuildings ? 1 : 0
                };

                if (gridBuildingsCount > 0) {
                    currentGrid.properties.buildingCount = gridBuildingsCount;
                    const gridIndexNum = drawnGrids.length + 1;
                    drawnGrids.push({ grid: currentGrid });

                    const geometry = currentGrid.geometry;
                    const coords = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    const wkt = `POLYGON ((${coords}, ${geometry.coordinates[0][0][0]} ${geometry.coordinates[0][0][1]}))`;

                    // Store grid in processedData.grids using gridIndexNum - 1 as the key
                    processedData.grids.set(gridIndexNum - 1, {
                        gridWKT: wkt,
                        clusterId: majorityCluster,
                        buildingCount: gridBuildingsCount,
                        geoJSON: currentGrid
                    });

                    currentGrid.properties.gridIndexNum = gridIndexNum;

                    // Update cluster building count using Map
                    const clusterId = parseInt(majorityCluster);
                    const clusterData = processedData.clusters.get(clusterId);
                    if (clusterData) {
                        clusterData.buildingCount = (clusterData.buildingCount || 0) + gridBuildingsCount;
                    } else {
                        processedData.clusters.set(clusterId, {
                            clusterId: clusterId,
                            buildingCount: gridBuildingsCount
                        });
                    }

                    gridFeatures.push(currentGrid);
                }
            });

            // Single L.geoJSON call for all grids
            const gridLayer = L.geoJSON({ type: "FeatureCollection", features: gridFeatures }, {
                style: feature => feature.properties.style,
                onEachFeature: (feature, layer) => {
                    if (feature.properties.buildingCount) {
                        layer.options.feature = {
                            gridIndex: feature.properties.gridIndexNum - 1
                        };
                        layer.bindTooltip(() => {
                            const clusterId = parseInt(layer.feature.properties.cluster);
                            const clusterData = processedData.clusters.get(clusterId);
                            const totalBuildings = clusterData ? clusterData.buildingCount : 0;
                            return `Service Area ${clusterId + 1} \n Total Buildings in Cluster: ${totalBuildings}`;
                        }, { sticky: true, direction: 'auto', opacity: 0.9 });

                        layer.on('click', () => {
                            reSizeMap('70%', false);
                            selectedGridIndex = feature.properties.gridIndexNum - 1;
                            const currentGridData = drawnGrids[selectedGridIndex].grid;
                            const currentCluster = currentGridData.properties.cluster;
                            const currentBuildingCount = currentGridData.properties.buildingCount;
                            $('#grid-no').text(`Delivery Unit: ${feature.properties.gridIndexNum}`);
                            $('#cluster-no').text(`Service Area: ${parseInt(currentCluster) + 1}`);
                            $('#grid-buildings').text(`Buildings in the DUs: ${currentBuildingCount}`);
                            $('#oa-no').text(`OA: ${index + 1}`);
                            $('#grid-color').html(`Service Area Color: <span class="color-box" style="background-color: ${getColorForNumber(currentCluster)};"></span>`);
                            setGridNeigboursInDropdown(currentCluster, currentGridData, clusterGroups, index, drawnGrids);
                        });
                    }
                }
            }).addTo(densityLayer);

            const buildingsToDraw = [];
            processedData.buildings.forEach((buildingData, buildingIndex) => {
                const buildingFeature = data.buildings.features[buildingIndex];
                if (buildingFeature) {
                    // Ensure cluster_label is set
                    const clusterId = buildingData.clusterId;
                    buildingFeature.properties.cluster_label = clusterId;
                    buildingsToDraw.push(buildingFeature);
                }
            });

            if (buildingsToDraw.length > 0) {
                const buildingsGeoJSON = turf.featureCollection(buildingsToDraw);
                L.geoJSON(buildingsGeoJSON, {
                    style: (feature) => {
                        const clusterId = parseInt(feature.properties.cluster_label);
                        const color = getColorForNumber(clusterId) || '#000000'; // Fallback to black if color is undefined
                        return {
                            color: 'black',
                            weight: 1,
                            fillColor: color,
                            fillOpacity: 0.9,
                            interactive: false
                        };
                    },
                    onEachFeature: (feature, layer) => {
                        const buildingIndex = data.buildings.features.findIndex(f => f === feature);
                        if (buildingIndex !== -1) {
                            data.buildings.features[buildingIndex].leafletLayer = layer;
                        }
                    }
                }).addTo(buildingLayer);

            }

            processedData.clusters.forEach((cluster, clusterId) => {
                const clusterBuildings = Array.from(processedData.buildings.values()).filter(b => b.clusterId === parseInt(clusterId));
                if (clusterBuildings.length > 0) {
                    const points = turf.featureCollection(clusterBuildings.map(b => turf.point(b.coordinates)));
                    const boundary = turf.convex(points);
                    const boundaryWKT = boundary ? `POLYGON ((${boundary.geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ')}))` : "N/A";
                    cluster.boundaryWKT = boundaryWKT;
                } else {
                    cluster.boundaryWKT = "N/A";
                }
                processedData.clusters.set(clusterId, cluster);
            });

            // Store processedData in polygonData
            polygonData.processedData = processedData;
            polygonData.drawnGrids = drawnGrids;
            polygonData.clusterGroups = clusterGroups;
            polygonData.gridLayer = gridLayer;
            polygonData.gridsDataExists = true
            // Update buttons
            enableOrDisableHtmlAttribute("clear-grids", false);
            enableOrDisableHtmlAttribute("download-csv-my-maps", false);
            enableOrDisableHtmlAttribute("download-csv-commcare", false);

        }

        function updateClusterBuildingCounts(processedData, oldClusterId, newClusterId, buildingCount) {

            // Update building counts in clusters using Map
            const oldClusterIdInt = parseInt(oldClusterId);
            const newClusterIdInt = parseInt(newClusterId);

            const oldCluster = processedData.clusters.get(oldClusterIdInt);
            const newCluster = processedData.clusters.get(newClusterIdInt);

            if (oldCluster) {
                oldCluster.buildingCount -= buildingCount;
                if (oldCluster.buildingCount <= 0) {
                    processedData.clusters.delete(oldClusterIdInt);
                } else {
                    processedData.clusters.set(oldClusterIdInt, oldCluster);
                }
            }

            if (newCluster) {
                newCluster.buildingCount += buildingCount;
                processedData.clusters.set(newClusterIdInt, newCluster);
            } else {
                processedData.clusters.set(newClusterIdInt, {
                    clusterId: newClusterIdInt,
                    buildingCount: buildingCount
                });
            }
        }

        function updateGridLayer(gridLayer, gridIndex, newClusterId, processedData, getColorForNumber, oldClusterId) {

            gridLayer.eachLayer((layer) => {
                const feature = layer?.options?.feature;
                if (!feature) {
                    return;
                }

                const layerGridIndex = feature.gridIndex;

                // Update the reassigned grid's color and cluster
                if (layerGridIndex === gridIndex) {
                    const newColor = getColorForNumber(newClusterId);
                    layer.setStyle({ color: newColor });

                    // Update the feature's cluster property
                    layer.feature.properties.cluster = newClusterId;

                    // Update the colors of the buildings in this grid
                    const gridData = processedData.grids.get(gridIndex);
                    if (gridData) {
                        processedData.buildings.forEach((buildingData, buildingIndex) => {
                            const buildingCoords = buildingData.coordinates;
                            const isInGrid = turf.booleanPointInPolygon(turf.point(buildingCoords), gridData.geoJSON);
                            if (isInGrid) {
                                const buildingFeature = buildingData.feature;
                                if (buildingFeature && buildingFeature.leafletLayer) {
                                    buildingFeature.leafletLayer.setStyle({
                                        fillColor: newColor
                                    });
                                    buildingFeature.properties.cluster_label = parseInt(newClusterId);
                                    buildingData.clusterId = parseInt(newClusterId);
                                    processedData.buildings.set(buildingIndex, buildingData);
                                }
                            }
                        });
                    }
                }
            });
        }

        function updateClusterCount(processedData, polygonData) {
            const clusterCount = processedData.clusters.size;
            $('#cluster-count-val').text(clusterCount);
        }

        function reassignGridToCluster() {
            const newClusterId = parseInt($('#neighbor-clusters').val());
            const oaNumber = parseInt($('#oa-no').text().replace('OA: ', ''));
            const polygonData = polygons[oaNumber-1];
            const processedData = polygonData.processedData;
            const gridData = processedData.grids.get(selectedGridIndex);
            const oldClusterId = parseInt(gridData.clusterId);
            const buildingCount = gridData.buildingCount;

            // Update clusterId in grid data
            gridData.clusterId = newClusterId;
            processedData.grids.set(selectedGridIndex, gridData);
            polygonData.drawnGrids[selectedGridIndex].grid.properties.cluster = newClusterId;

            // Update building counts
            updateClusterBuildingCounts(processedData, oldClusterId, newClusterId, buildingCount);
            updateGridLayer(polygonData.gridLayer, selectedGridIndex, newClusterId, processedData, getColorForNumber, oldClusterId);

            // Update UI
            $('#cluster-no').text(`Service Area: ${newClusterId + 1}`);
            $('#grid-color').html(`Service Area Color: <span class="color-box" style="background-color: ${getColorForNumber(newClusterId)};"></span>`);

            // Update cluster count
            updateClusterCount(processedData, polygonData);
        }

        function setGridNeigboursInDropdown(currentCluster, currentGridData, clusterGroups, drawnGrids) {
            const boundaries = computeBoundaries(clusterGroups);
            const dropdown = $('#neighbor-clusters');
            dropdown.empty();

            const neighborClusters = new Set();
            const currentOption = $('<option>').val(currentCluster).text(`Service Area ${parseInt(currentCluster) + 1} (Current)`);
            dropdown.append(currentOption);
            neighborClusters.add(parseInt(currentCluster));

            Object.entries(boundaries).forEach(([clusterId, boundary]) => {
                if (turf.intersect(currentGridData, boundary)) {
                    neighborClusters.add(parseInt(clusterId));
                }
            });

            const gridBbox = turf.bbox(currentGridData);
            const gridWidth = gridBbox[2] - gridBbox[0];
            const gridHeight = gridBbox[3] - gridBbox[1];
            const adjacentOffsets = [
                { dx: -gridWidth, dy: 0 },
                { dx: gridWidth, dy: 0 },
                { dx: 0, dy: gridHeight },
                { dx: 0, dy: -gridHeight }
            ];

            adjacentOffsets.forEach(offset => {
                const adjacentGrid = turf.transformTranslate(
                    currentGridData,
                    Math.sqrt(offset.dx * offset.dx + offset.dy * offset.dy),
                    Math.atan2(offset.dy, offset.dx) * 180 / Math.PI,
                    { units: 'degrees' }
                );

                let assignedCluster = null;
                for (let i = 0; i < drawnGrids.length; i++) {
                    const drawnGrid = drawnGrids[i].grid;
                    if (turf.booleanEqual(adjacentGrid, drawnGrid)) {
                        assignedCluster = parseInt(drawnGrid.cluster);
                        break;
                    }
                }

                if (assignedCluster !== null) {
                    neighborClusters.add(assignedCluster);
                } else {
                    const majorityCluster = findMajorityCluster(adjacentGrid, boundaries);
                    if (majorityCluster !== null) {
                        neighborClusters.add(parseInt(majorityCluster));
                    }
                }
            });

            Array.from(neighborClusters)
                .filter(clusterId => clusterId !== parseInt(currentCluster))
                .sort((a, b) => a - b)
                .forEach(clusterId => {
                    const option = $('<option>').val(clusterId).text(`Service Area ${parseInt(clusterId) + 1}`);
                    dropdown.append(option);
                });
        }

        function groupClusters(clusters) {
            const clusterGroups = {};
            clusters.forEach((feature, index) => {
                const { cluster, coordinates } = feature;
                if (!clusterGroups[cluster]) {
                    clusterGroups[cluster] = { points: [], indices: [] };
                }
                clusterGroups[cluster].points.push(coordinates);
                clusterGroups[cluster].indices.push(index);
            });
            return clusterGroups;
        }

        function computeBoundaries(clusterGroups) {
            const boundaries = {};
            Object.entries(clusterGroups).forEach(([clusterId, { points }]) => {
                if (points.length > 2) {
                    const turfPoints = points.map(p => turf.point(p));
                    const featureCollection = turf.featureCollection(turfPoints);
                    boundaries[clusterId] = turf.convex(featureCollection);
                }
            });
            return boundaries;
        }

        function getExpandedBbox(featureCollection, buffer) {
            const bbox = turf.bbox(featureCollection);
            return [bbox[0] - buffer, bbox[1] - buffer, bbox[2] + buffer, bbox[3] + buffer];
        }

        function getBuildingsInGrid(allBuildings, grid, assignedBuildingIndices) {
            return turf.featureCollection(
                allBuildings.features.filter((point, buildingIndex) => {
                    if (turf.booleanPointInPolygon(point, grid)) {
                        assignedBuildingIndices.add(buildingIndex);
                        return true;
                    }
                    return false;
                })
            );
        }

        function findMajorityCluster(grid, boundaries) {
            const intersectingClusters = [];
            Object.entries(boundaries).forEach(([clusterId, boundary]) => {
                const intersection = turf.intersect(grid, boundary);
                if (intersection) {
                    const area = turf.area(intersection);
                    intersectingClusters.push({ clusterId, area });
                }
            });
            if (intersectingClusters.length === 0) return null;
            intersectingClusters.sort((a, b) => b.area - a.area);
            return intersectingClusters[0].clusterId;
        }

        function reassignAndDrawBuildings(index, buildingsInGrid, majorityCluster, data, assignedBuildings, processedData, gridIndexNum) {
            const polygonData = polygons[index];
            if (!polygonData) {
                console.error("reassignAndDrawBuildings - Invalid polygonData for index:", index);
                return;
            }
            if (!data || !data.clusters) {
                console.error("data.clusters is undefined in reassignAndDrawBuildings", data);
                return;
            }

            // Use coordinates to track assigned buildings
            buildingsInGrid.features.forEach(point => {
                const buildingIndex = data.clusters.findIndex(c =>
                    c.coordinates[0] === point.geometry.coordinates[0] &&
                    c.coordinates[1] === point.geometry.coordinates[1]
                );
                if (buildingIndex === -1) {
                    console.warn(`reassignAndDrawBuildings - No building found in data.clusters for point:`, point);
                    return;
                }

                const coordKey = `${data.clusters[buildingIndex].coordinates[0]},${data.clusters[buildingIndex].coordinates[1]}`;
                if (assignedBuildings.has(coordKey)) {
                    return;
                }

                // Update the cluster assignment
                data.clusters[buildingIndex].cluster = parseInt(majorityCluster);
                assignedBuildings.add(coordKey);

                // Update the building's cluster_label
                const buildingFeature = data.buildings.features[buildingIndex];
                if (buildingFeature) {
                    buildingFeature.properties.cluster_label = parseInt(majorityCluster);
                    const geometry = buildingFeature.geometry;
                    const wkt = geometry.coordinates[0].map(coord => `${coord[0]} ${coord[1]}`).join(', ');
                    // Store building data in processedData.buildings for later updates
                    processedData.buildings.set(buildingIndex, {
                        coordinates: point.geometry.coordinates,
                        clusterId: parseInt(majorityCluster),
                        feature: buildingFeature,
                        gridIndex: gridIndexNum -1,
                        wkt: wkt
                    });
                }
            });
        }

        function downloadGmapData() {
            const polygonData = polygons[selectedPolygonIndex];
            if (!polygonData || !polygonData.processedData) {
                console.error("No processed data available for download at index:", index, polygonData);
                return;
            }
            const processedData = polygonData.processedData;
            if (!processedData.clusters.size && !processedData.grids.size && !processedData.buildings.size) {
                console.error("No processed data available for download");
                return;
            }
            let clusterCsvContent = "WKT,name,description,SA,OA\n";
            processedData.clusters.forEach((cluster, clusterId) => {
                clusterCsvContent += `"${cluster.boundaryWKT}",SA ${parseInt(cluster.clusterId) + 1},${cluster.buildingCount},-,${selectedPolygonIndex + 1}\n`;
            });
            processedData.grids.forEach((grid, index) => {
                if (grid.buildingCount > 0) {
                    clusterCsvContent += `"${grid.gridWKT}",DU ${index + 1},${grid.buildingCount},${parseInt(grid.clusterId) + 1},${selectedPolygonIndex + 1}\n`;
                }
            });
            let buildingsCsvContent = "Name,OA,SA,DU,latitude,longitude,area_in_meters,confidence,geometry,full_plus_code\n";
            processedData.buildings.forEach((building, index) => {
                const featureProps = building.feature.properties || {};
                const gridIndex = building.gridIndex !== undefined ? building.gridIndex + 1 : "N/A";
                const latitude = building.coordinates[1];
                const longitude = building.coordinates[0];
                const areaInMeters = featureProps.area_in_meters || "N/A";
                const confidence = featureProps.confidence || "N/A";
                const fullPlusCode = featureProps.full_plus_code || "N/A";
                buildingsCsvContent += `Building ${index + 1},${selectedPolygonIndex + 1},${parseInt(building.clusterId) + 1},${gridIndex},${latitude},${longitude},${areaInMeters},${confidence},"${building.wkt}",${fullPlusCode}\n`;
            });
            downloadCsv(clusterCsvContent, 'service_area_&_delivery_units.csv');
            downloadCsv(buildingsCsvContent, 'buildings.csv');
            downloadOAWkt();
            showToast("CSV downloaded! Import into Google My Maps at mymaps.google.com.", "success", 3000, "#00FF00");
        }

        function downloadCsvForCommCare() {
            const polygonData = polygons[selectedPolygonIndex];
            if (!polygonData || !polygonData.processedData) {
                console.error("No processed data available for download at index:", index, polygonData);
                return;
            }
            const processedData = polygonData.processedData;
            let csvContent = "name,delivery_target,delivery_count,radius,centroid,bounding_box,service_area,flw,WKT,distance between adj sides 1,distance between adj sides 2,#Buildings,Surface Area (sq. meters), OA\n";
            processedData.grids.forEach((grid, index) => {
                if (grid.buildingCount === 0) return;
                const geometry = grid.geoJSON.geometry;
                const bbox = turf.bbox(grid.geoJSON);
                const widthDeg = bbox[2] - bbox[0];
                const heightDeg = bbox[3] - bbox[1];
                const widthMeters = widthDeg * 111000 * Math.cos(turf.centroid(grid.geoJSON).geometry.coordinates[1] * Math.PI / 180);
                const heightMeters = heightDeg * 111000;
                const radius = widthMeters / 2;
                const centroid = turf.centroid(grid.geoJSON).geometry.coordinates;
                const centroidStr = `${centroid[1]} ${centroid[0]}`;
                const boundingBox = geometry.coordinates[0].map(coord => `${coord[1]} ${coord[0]}`).join(' ');
                const surfaceArea = turf.area(grid.geoJSON);
                const gridName = `Delivery Unit ${index + 1}`;
                const deliveryTarget = 1, deliveryCount = 0;
                csvContent += `"${gridName}",${deliveryTarget},${deliveryCount},${radius},"${centroidStr}",${boundingBox},${parseInt(grid.clusterId) + 1},"","${grid.gridWKT}",${widthMeters},${heightMeters},${grid.buildingCount},${surfaceArea},${selectedPolygonIndex + 1}\n`;
            });
            downloadCsv(csvContent, 'csv_for_CommCare.csv');
            showToast("CommCare CSV downloaded!", "success", 3000, "#00FF00");
        }

        function downloadSampleCsv() {
            const clusterCsvContent = `LLO Name,Total Area\n"Test LLO","POLYGON ((13.1623186 11.8734809, 13.1623186 11.8605101, 13.1755186 11.8605101, 13.1755186 11.8734809, 13.1623186 11.8734809))"`;
            downloadCsv(clusterCsvContent, 'sample_csv_file.csv');
        }

        function downloadCsv(csvContent, fileName) {
            const blob = new Blob([csvContent], { type: "text/csv" });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function uploadCSVPolygon() {
            clearOA();
            const fileInput = $('#csvUpload')[0];
            const file = fileInput.files[0];
            if (!file) return showToast("Please select a CSV file.", "warning", 3000, "#FFA500");
            const reader = new FileReader();
            reader.onload = function (event) {
                let successCount = 0;
                let errorCount = 0;
                try {
                    const rows = event.target.result.split('\n').filter(row => row.trim());
                    if (rows.length < 2) throw new Error("CSV has no data rows.");
                    const parseCSVRow = row => {
                        const fields = [];
                        let inQuotes = false, field = '';
                        for (let char of row) {
                            if (char === '"') inQuotes = !inQuotes;
                            else if (char === ',' && !inQuotes) {
                                fields.push(field.trim());
                                field = '';
                            } else field += char;
                        }
                        fields.push(field.trim());
                        return fields;
                    };
                    const header = parseCSVRow(rows[0]);
                    for (let i = 1; i < rows.length; i++) {
                        try {
                            const dataRow = parseCSVRow(rows[i]);
                            if (dataRow.length < 2) throw new Error(`Row ${i + 1}: Lacks sufficient columns.`);
                            const wktString = dataRow[1];
                            if (!wktString.match(/^POLYGON \(\(.*\)\)$/)) throw new Error(`Row ${i + 1}: Invalid POLYGON format.`);
                            const coordsStr = wktString.match(/POLYGON \(\((.*?)\)\)/)?.[1];
                            if (!coordsStr) throw new Error(`Row ${i + 1}: Coordinates should not be empty`);
                            const latLngs = coordsStr.split(/, ?/).map(coord => {
                                const [lon, lat] = coord.split(' ').map(Number);
                                if (isNaN(lon) || isNaN(lat)) throw new Error(`Row ${i + 1}: Invalid coordinate values.`);
                                return [lat, lon];
                            });
                            const mockLayer = {
                                getLatLngs: () => [latLngs.map(([lat, lng]) => ({ lat, lng }))],
                                getBounds: () => L.latLngBounds(latLngs)
                            };
                            addOrUpdatePolygon(mockLayer);
                            successCount++;
                            showToast(`Row ${i + 1}: OA loaded from CSV!`, "success", 2000, "#4CAF50");
                        } catch (error) {
                            errorCount++;
                            showToast(`Error: ${error.message}`, "error", 3000, "#FF0000");
                            return
                        }
                    }
                    if (successCount > 0 && errorCount === 0) {
                        $('#uploaded-file-name').text(file.name);
                        showToast(`${successCount} polygon(s) loaded successfully!`, "success", 3000, "#4CAF50");
                    }
                    if (successCount === 0 && errorCount > 0) {
                        $('#uploaded-file-name').text('No File Chosen');
                    }
                } catch (error) {
                    showToast(`Error: ${error.message}`, "error", 3000, "#FF0000");
                    $('#uploaded-file-name').text('No File Chosen');
                } finally {
                    fileInput.value = '';
                }
            };
            reader.onerror = () => showToast("Error reading CSV file.", "error", 3000, "#FF0000");
            reader.readAsText(file);
        }

        function validateClusteringInputs(clusteringType, pinLatLng, polygon) {
            const showWarning = (message) => {
                showToast(message, "warning", 3000, "#FFA500");
                $('#run-clustering, #clear-oa, #download-oa-wkt').prop('disabled', false);
            };
            if (clusteringType === "bottomUp" && !pinLatLng) {
                showWarning("Please drop a pin on the map first.");
                return false;
            }
            if (clusteringType !== "bottomUp" && (!polygon || polygon.length === 0)) {
                showWarning("Please draw a polygon on the map first.");
                return false;
            }
            return true;
        }

        function fetchData(index, polygon, pinLatLng, fetchClusters) {
            if (index === -1 && !pinLatLng) {
                showToast("Please select a polygon or drop a pin.", "warning", 3000, "#FFA500");
                return;
            }
            const polygonData = polygons[index];
            if (polygonData.data && !fetchClusters) {
                $('#building-count').text(polygonData.buildingCount ?? 0);
                addBuildings(index, polygonData.data);
                updateSelectedPolygon();
                return;
            }
            polygonData.densityLayer.clearLayers();
            polygonData.clusterLayer.clearLayers();
            let thresholdVal = $('#thresholdVal').val() || 0.5;
            if (thresholdVal > 100) thresholdVal = 100;
            if (thresholdVal < 0) thresholdVal = 0;
            const clusteringType = $('#clusteringType').val();
            const dbType = $('#DBtype').val();
            let noOfClusters = $('#noOfClusters').val();
            if (noOfClusters <= 0) noOfClusters = 1;
            let noOfBuildings = $('#noOfBuildings').val();
            if (noOfBuildings <= 0) noOfBuildings = 1;
            const gridLength = $('#gridLength').val();

            if (!validateClusteringInputs(clusteringType, pinLatLng, polygon)) {
                return;
            }

            const requestBody = {
                pin: pinLatLng,
                polygon,
                clusteringType,
                noOfClusters,
                noOfBuildings,
                gridLength,
                thresholdVal,
                fetchClusters,
                dbType
            };
            showToast('Fetching data...', 'info', undefined, '#ff9300');
            fetch(`${hostUrl}/get_building_density`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            })
                .then(response => {
                    if (fetchClusters) {
                        enableOrDisableHtmlAttribute("clear-clusters", false);
                    }
                    enableOrDisableHtmlAttribute("clear-oa", false);
                    enableOrDisableHtmlAttribute("download-oa-wkt", false);
                    enableOrDisableHtmlAttribute("download-btn", false);
                    enableOrDisableHtmlAttribute("run-clustering", false);
                    return response.json();
                })
                .then(data => {
                    Swal.close();
                    if (data.error) {
                        showToast(`Error: ${data.error}`, 'error', 5000, '#FF0000', '300px');
                    } else {
                        showToast('Data loaded!', 'success', 2000, '#4CAF50');
                        polygonData.buildingCount = data.building_count ?? 0;
                        $('#building-count').text(polygonData.buildingCount);
                        if (data.building_count == 0) showToast(`No Buildings in the OA`, 'error', 5000, '#FF0000', '300px');
                        polygonData.data = data;
                        if (fetchClusters) {
                            polygonData.clustersData = data;
                            addClusters(index, data, true);
                            enableOrDisableHtmlAttribute("get-grids", false);
                        }
                        addBuildings(index, data);
                        updateSelectedPolygon();
                    }
                })
                .catch(error => {
                    Swal.close();
                    showToast(`Error: ${error.message}`, 'error', 5000, '#FF0000', '300px');
                    console.error('Error:', error);
                    $('#building-count').text("Error fetching data");
                    enableOrDisableHtmlAttribute("clear-clusters", false);
                    enableOrDisableHtmlAttribute("clear-oa", false);
                    enableOrDisableHtmlAttribute("download-oa-wkt", false);
                    enableOrDisableHtmlAttribute("download-btn", false);
                });
        }

        function downloadOAWkt() {
            const polygonData = polygons[selectedPolygonIndex];
            const coordsStr = polygonData.latlngs.map(coord => `${coord[0]} ${coord[1]}`).join(', ');
            const wkt = `POLYGON ((${coordsStr}))`;
            const csvContent = `OA Wkt\n"${wkt}"`;
            downloadCsv(csvContent, `oa_${selectedPolygonIndex + 1}_wkt.csv`);
            showToast("OA WKT downloaded!", "success", 2000, "#4CAF50");
        }

        $(document).ready(function () {
            toggleInputFields();
            $('#sidebar-toggle-btn').on('click', toggleSidebar);
        });

        function toggleSidebar() {
            const $rightPanel = $('#right-panel');
            const $leftPanel = $('#left-panel');
            const $toggleBtn = $('#sidebar-toggle-btn i');
            if ($rightPanel.hasClass('collapsed')) {
                $rightPanel.removeClass('collapsed');
                $leftPanel.removeClass('expanded');
                $toggleBtn.removeClass('bi-chevron-left').addClass('bi-chevron-right');
                $('#sidebar-toggle-btn').attr('title', 'Collapse Sidebar');
            } else {
                $rightPanel.addClass('collapsed');
                $leftPanel.addClass('expanded');
                $toggleBtn.removeClass('bi-chevron-right').addClass('bi-chevron-left');
                $('#sidebar-toggle-btn').attr('title', 'Expand Sidebar');
            }
            setTimeout(() => map.invalidateSize(), 300);
        }

        $('#run-clustering').on('click', () => {
            if (selectedPolygonIndex !== -1) {
                fetchData(selectedPolygonIndex, polygons[selectedPolygonIndex].latlngs, pinLatLng, true);
            } else {
                showToast("Please select a polygon.", "warning", 3000, "#FFA500");
            }
        });

        $('#clear-clusters').on('click', () => {
            if (selectedPolygonIndex !== -1) {
                clearClusters(selectedPolygonIndex, false);
            } else {
                showToast("Please select a polygon.", "warning", 3000, "#FFA500");
            }
        });

        $('#get-grids').on('click', () => {
            if (selectedPolygonIndex !== -1) {
                const polygonData = polygons[selectedPolygonIndex];
                if (polygonData.clustersData) {
                    drawGrids(selectedPolygonIndex, polygonData.clustersData);
                } else {
                    showToast("Please get service areas first.", "warning", 3000, "#FFA500");
                }
            } else {
                showToast("Please select a polygon.", "warning", 3000, "#FFA500");
            }
        });

        $('#clear-grids').on('click', () => {
            if (selectedPolygonIndex !== -1) {
                clearGrids(selectedPolygonIndex);
                const polygonData = polygons[selectedPolygonIndex];
                if (polygonData.clustersData) {
                    addClusters(selectedPolygonIndex, polygonData.clustersData, true);
                }
            } else {
                showToast("Please select a polygon.", "warning", 3000, "#FFA500");
            }
        });

        // Dropdown menu for Download button
        const downloadBtn = document.getElementById('download-btn');
        const downloadMenu = document.getElementById('download-menu');

        // Toggle dropdown menu on click
        downloadBtn.addEventListener('click', () => {
            if (!downloadBtn.disabled) {
                downloadMenu.style.display = downloadMenu.style.display === 'block' ? 'none' : 'block';
                downloadBtn.setAttribute('aria-expanded', downloadMenu.style.display === 'block' ? 'true' : 'false');
            }
        });

        // Hide dropdown when clicking outside
        document.addEventListener('click', (event) => {
            if (!downloadBtn.contains(event.target) && !downloadMenu.contains(event.target)) {
                downloadMenu.style.display = 'none';
                downloadBtn.setAttribute('aria-expanded', 'false');
            }
        });

        // Handle download options
        document.getElementById('download-oa-wkt').addEventListener('click', () => {
            downloadMenu.style.display = 'none';
            downloadBtn.setAttribute('aria-expanded', 'false');
            downloadOAWkt();
        });

        document.getElementById('download-csv-my-maps').addEventListener('click', () => {
            downloadMenu.style.display = 'none';
            downloadBtn.setAttribute('aria-expanded', 'false');
            downloadGmapData();
        });

        document.getElementById('download-csv-commcare').addEventListener('click', () => {
            downloadMenu.style.display = 'none';
            downloadBtn.setAttribute('aria-expanded', 'false');
            downloadCsvForCommCare();
        });
    </script>
</body>
</html>